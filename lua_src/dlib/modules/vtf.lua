
-- Copyright (C) 2017-2020 DBotThePony

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do so,
-- subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all copies
-- or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
-- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
-- PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
-- FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-- DEALINGS IN THE SOFTWARE.

DLib._NEXT_VTF_PROGRESS_IDENTIFIER = DLib._NEXT_VTF_PROGRESS_IDENTIFIER or 0

_G.TEXTUREFLAGS_POINTSAMPLE                   = 0x00000001
_G.TEXTUREFLAGS_TRILINEAR                     = 0x00000002
_G.TEXTUREFLAGS_CLAMPS                        = 0x00000004
_G.TEXTUREFLAGS_CLAMPT                        = 0x00000008
_G.TEXTUREFLAGS_ANISOTROPIC                   = 0x00000010
_G.TEXTUREFLAGS_HINT_DXT5                     = 0x00000020
_G.TEXTUREFLAGS_SRGB                          = 0x00000040
_G.TEXTUREFLAGS_NORMAL                        = 0x00000080
_G.TEXTUREFLAGS_NOMIP                         = 0x00000100
_G.TEXTUREFLAGS_NOLOD                         = 0x00000200
_G.TEXTUREFLAGS_ALL_MIPS                      = 0x00000400
_G.TEXTUREFLAGS_PROCEDURAL                    = 0x00000800

-- These are automatically generated by vtex from the texture data.
_G.TEXTUREFLAGS_ONEBITALPHA                   = 0x00001000
_G.TEXTUREFLAGS_EIGHTBITALPHA                 = 0x00002000

-- newer flags from the *.txt config file
_G.TEXTUREFLAGS_ENVMAP                        = 0x00004000
_G.TEXTUREFLAGS_RENDERTARGET                  = 0x00008000
_G.TEXTUREFLAGS_DEPTHRENDERTARGET             = 0x00010000
_G.TEXTUREFLAGS_NODEBUGOVERRIDE               = 0x00020000
_G.TEXTUREFLAGS_SINGLECOPY                    = 0x00040000
_G.TEXTUREFLAGS_STAGING_MEMORY                = 0x00080000
_G.TEXTUREFLAGS_IMMEDIATE_CLEANUP             = 0x00100000
_G.TEXTUREFLAGS_IGNORE_PICMIP                 = 0x00200000
_G.TEXTUREFLAGS_UNUSED_00400000               = 0x00400000
_G.TEXTUREFLAGS_NODEPTHBUFFER                 = 0x00800000
_G.TEXTUREFLAGS_UNUSED_01000000               = 0x01000000
_G.TEXTUREFLAGS_CLAMPU                        = 0x02000000
_G.TEXTUREFLAGS_VERTEXTEXTURE                 = 0x04000000                 -- Useable as a vertex texture
_G.TEXTUREFLAGS_SSBUMP                        = 0x08000000
_G.TEXTUREFLAGS_UNUSED_10000000               = 0x10000000

-- Clamp to border color on all texture coordinates
_G.TEXTUREFLAGS_BORDER                        = 0x20000000
_G.TEXTUREFLAGS_UNUSED_40000000               = 0x40000000
_G.TEXTUREFLAGS_UNUSED_80000000               = 0x80000000

local TEXTUREFLAGS_POINTSAMPLE =       TEXTUREFLAGS_POINTSAMPLE
local TEXTUREFLAGS_TRILINEAR =         TEXTUREFLAGS_TRILINEAR
local TEXTUREFLAGS_CLAMPS =            TEXTUREFLAGS_CLAMPS
local TEXTUREFLAGS_CLAMPT =            TEXTUREFLAGS_CLAMPT
local TEXTUREFLAGS_ANISOTROPIC =       TEXTUREFLAGS_ANISOTROPIC
local TEXTUREFLAGS_HINT_DXT5 =         TEXTUREFLAGS_HINT_DXT5
local TEXTUREFLAGS_SRGB =              TEXTUREFLAGS_SRGB
local TEXTUREFLAGS_NORMAL =            TEXTUREFLAGS_NORMAL
local TEXTUREFLAGS_NOMIP =             TEXTUREFLAGS_NOMIP
local TEXTUREFLAGS_NOLOD =             TEXTUREFLAGS_NOLOD
local TEXTUREFLAGS_ALL_MIPS =          TEXTUREFLAGS_ALL_MIPS
local TEXTUREFLAGS_PROCEDURAL =        TEXTUREFLAGS_PROCEDURAL
local TEXTUREFLAGS_ONEBITALPHA =       TEXTUREFLAGS_ONEBITALPHA
local TEXTUREFLAGS_EIGHTBITALPHA =     TEXTUREFLAGS_EIGHTBITALPHA
local TEXTUREFLAGS_ENVMAP =            TEXTUREFLAGS_ENVMAP
local TEXTUREFLAGS_RENDERTARGET =      TEXTUREFLAGS_RENDERTARGET
local TEXTUREFLAGS_DEPTHRENDERTARGET = TEXTUREFLAGS_DEPTHRENDERTARGET
local TEXTUREFLAGS_NODEBUGOVERRIDE =   TEXTUREFLAGS_NODEBUGOVERRIDE
local TEXTUREFLAGS_SINGLECOPY =        TEXTUREFLAGS_SINGLECOPY
local TEXTUREFLAGS_STAGING_MEMORY =    TEXTUREFLAGS_STAGING_MEMORY
local TEXTUREFLAGS_IMMEDIATE_CLEANUP = TEXTUREFLAGS_IMMEDIATE_CLEANUP
local TEXTUREFLAGS_IGNORE_PICMIP =     TEXTUREFLAGS_IGNORE_PICMIP
local TEXTUREFLAGS_UNUSED_00400000 =   TEXTUREFLAGS_UNUSED_00400000
local TEXTUREFLAGS_NODEPTHBUFFER =     TEXTUREFLAGS_NODEPTHBUFFER
local TEXTUREFLAGS_UNUSED_01000000 =   TEXTUREFLAGS_UNUSED_01000000
local TEXTUREFLAGS_CLAMPU =            TEXTUREFLAGS_CLAMPU
local TEXTUREFLAGS_VERTEXTEXTURE =     TEXTUREFLAGS_VERTEXTEXTURE
local TEXTUREFLAGS_SSBUMP =            TEXTUREFLAGS_SSBUMP
local TEXTUREFLAGS_UNUSED_10000000 =   TEXTUREFLAGS_UNUSED_10000000
local TEXTUREFLAGS_BORDER =            TEXTUREFLAGS_BORDER
local TEXTUREFLAGS_UNUSED_40000000 =   TEXTUREFLAGS_UNUSED_40000000
local TEXTUREFLAGS_UNUSED_80000000 =   TEXTUREFLAGS_UNUSED_80000000


local VTF = {}
local VTFObject = {}

local Formats = {
	'IMAGE_FORMAT_NONE',
	'IMAGE_FORMAT_RGBA8888',
	'IMAGE_FORMAT_ABGR8888',
	'IMAGE_FORMAT_RGB888',
	'IMAGE_FORMAT_BGR888',
	'IMAGE_FORMAT_RGB565',
	'IMAGE_FORMAT_I8',
	'IMAGE_FORMAT_IA88',
	'IMAGE_FORMAT_P8',
	'IMAGE_FORMAT_A8',
	'IMAGE_FORMAT_RGB888_BLUESCREEN',
	'IMAGE_FORMAT_BGR888_BLUESCREEN',
	'IMAGE_FORMAT_ARGB8888',
	'IMAGE_FORMAT_BGRA8888',
	'IMAGE_FORMAT_DXT1',
	'IMAGE_FORMAT_DXT3',
	'IMAGE_FORMAT_DXT5',
	'IMAGE_FORMAT_BGRX8888',
	'IMAGE_FORMAT_BGR565',
	'IMAGE_FORMAT_BGRX5551',
	'IMAGE_FORMAT_BGRA4444',
	'IMAGE_FORMAT_DXT1_ONEBITALPHA',
	'IMAGE_FORMAT_BGRA5551',
	'IMAGE_FORMAT_UV88',
	'IMAGE_FORMAT_UVWQ8888',
	'IMAGE_FORMAT_RGBA16161616F',
	'IMAGE_FORMAT_RGBA16161616',
	'IMAGE_FORMAT_UVLX8888'
}

VTFObject.Formats = {}

for i = 1, #Formats do
	VTFObject.Formats[Formats[i]] = i - 2
	VTFObject.Formats[i - 2] = Formats[i]

	_G[Formats[i]] = i - 2
end

VTFObject.Readers = {}
VTFObject.Readers.IMAGE_FORMAT_DXT1 = DLib.DXT1
VTFObject.Readers.IMAGE_FORMAT_DXT1_ONEBITALPHA = DLib.DXT1
VTFObject.Readers.IMAGE_FORMAT_DXT3 = DLib.DXT3
VTFObject.Readers.IMAGE_FORMAT_DXT5 = DLib.DXT5
VTFObject.Readers.IMAGE_FORMAT_RGBA8888 = DLib.RGBA8888
VTFObject.Readers.IMAGE_FORMAT_BGRA8888 = DLib.BGRA8888
VTFObject.Readers.IMAGE_FORMAT_BGRX8888 = DLib.BGRA8888 -- ???
VTFObject.Readers.IMAGE_FORMAT_ARGB8888 = DLib.ARGB8888
VTFObject.Readers.IMAGE_FORMAT_ABGR8888 = DLib.ABGR8888
VTFObject.Readers.IMAGE_FORMAT_RGB888 = DLib.RGB888
VTFObject.Readers.IMAGE_FORMAT_BGR888_BLUESCREEN = DLib.BGR888 -- ???
VTFObject.Readers.IMAGE_FORMAT_RGB888_BLUESCREEN = DLib.RGB888 -- ???
VTFObject.Readers.IMAGE_FORMAT_BGR888 = DLib.BGR888
VTFObject.Readers.IMAGE_FORMAT_RGB565 = DLib.RGB565
VTFObject.Readers.IMAGE_FORMAT_BGR565 = DLib.BGR565
VTFObject.Readers.IMAGE_FORMAT_BGRA4444 = DLib.BGRA4444
VTFObject.Readers.IMAGE_FORMAT_BGRA5551 = DLib.BGRA5551
VTFObject.Readers.IMAGE_FORMAT_BGRX5551 = DLib.BGRA5551 -- ???
VTFObject.Readers.IMAGE_FORMAT_I8 = DLib.I8
VTFObject.Readers.IMAGE_FORMAT_IA88 = DLib.IA88
VTFObject.Readers.IMAGE_FORMAT_A8 = DLib.A8

VTFObject.AlphaFormats = {
	IMAGE_FORMAT_DXT3 = true,
	IMAGE_FORMAT_DXT5 = true,
	IMAGE_FORMAT_RGBA8888 = true,
	IMAGE_FORMAT_BGRA8888 = true,
	IMAGE_FORMAT_BGRX8888 = true,
	IMAGE_FORMAT_ARGB8888 = true,
	IMAGE_FORMAT_ABGR8888 = true,
	IMAGE_FORMAT_BGRA4444 = true,
	IMAGE_FORMAT_BGRA5551 = true,
	IMAGE_FORMAT_BGRX5551 = true,
	IMAGE_FORMAT_IA88 = true,
	IMAGE_FORMAT_A8 = true,
}

VTFObject.EightBitAlpha = {
	IMAGE_FORMAT_RGBA8888 = true,
	IMAGE_FORMAT_BGRA8888 = true,
	IMAGE_FORMAT_BGRX8888 = true,
	IMAGE_FORMAT_ARGB8888 = true,
	IMAGE_FORMAT_ABGR8888 = true,
	IMAGE_FORMAT_BGRA4444 = true,
	IMAGE_FORMAT_BGRA5551 = true,
	IMAGE_FORMAT_BGRX5551 = true,
	IMAGE_FORMAT_IA88 = true,
	IMAGE_FORMAT_A8 = true,
}

local color_white = Color()

local power_of_two = {}

for i = 0, 14 do
	power_of_two[math.pow(2, i)] = i
end

--[[
	@doc
	@fname DLib.VTF.Create
	@args number version, number width, number height, number format, table extra = {}

	@desc
	`version` is a number between 1 and 5 (inclusive) for 7.1 to 7.5 VTF versions respectively
	`width` and `height` must be a power of two
	`format` must be `IMAGE_FORMAT_` global enum:

	```lua
		local Formats = {
		'IMAGE_FORMAT_NONE',
		'IMAGE_FORMAT_RGBA8888',
		'IMAGE_FORMAT_ABGR8888',
		'IMAGE_FORMAT_RGB888',
		'IMAGE_FORMAT_BGR888',
		'IMAGE_FORMAT_RGB565',
		'IMAGE_FORMAT_I8',
		'IMAGE_FORMAT_IA88',
		'IMAGE_FORMAT_P8',
		'IMAGE_FORMAT_A8',
		'IMAGE_FORMAT_RGB888_BLUESCREEN',
		'IMAGE_FORMAT_BGR888_BLUESCREEN',
		'IMAGE_FORMAT_ARGB8888',
		'IMAGE_FORMAT_BGRA8888',
		'IMAGE_FORMAT_DXT1',
		'IMAGE_FORMAT_DXT3',
		'IMAGE_FORMAT_DXT5',
		'IMAGE_FORMAT_BGRX8888',
		'IMAGE_FORMAT_BGR565',
		'IMAGE_FORMAT_BGRX5551',
		'IMAGE_FORMAT_BGRA4444',
		'IMAGE_FORMAT_DXT1_ONEBITALPHA',
		'IMAGE_FORMAT_BGRA5551',
		'IMAGE_FORMAT_UV88',
		'IMAGE_FORMAT_UVWQ8888',
		'IMAGE_FORMAT_RGBA16161616F',
		'IMAGE_FORMAT_RGBA16161616',
		'IMAGE_FORMAT_UVLX8888'
	}
	```

	extra is an optional table that might include:
	`resources` table (key -> value, 7.3+ only, filled automatically)
	`flags` number (for creating envmaps you must set it)
	`frames` number
	`first_frame` number
	`fill` Color (defaults to white)
	`bumpmap_scale` number
	`mipmap_count` can be a positive number (exact), negative (auto - mipmap_count), or `true` (auto)
	`depth` number
	`force_no_eightbitalpha` boolean (do not specify `TEXTUREFLAGS_EIGHTBITALPHA` if applicable)

	@enddesc

	@returns
	table: newly created DLib.VTF
]]
-- version is a number from 1 (7.1) to 5 (7.5)
function VTFObject.Create(version, width, height, format, extra)
	assert(isnumber(version), 'isnumber(version)', 2)
	version = version:floor()
	assert(version >= 1 and version <= 5, 'version does not belong to [1, 5] interval', 2)

	assert(isnumber(width), 'isnumber(width)', 2)
	assert(isnumber(height), 'isnumber(height)', 2)
	assert(power_of_two[width], 'Width is not power of two', 2)
	assert(power_of_two[height], 'Height is not power of two', 2)

	if isstring(format) then
		format = assert(VTFObject.Formats[format], 'Invalid format ' .. format .. '!', 2)
	elseif not VTFObject.Formats[format] then
		error('Invalid format index ' .. format .. '!', 2)
	end

	local reader = VTFObject.Readers[VTFObject.Formats[format]]
	if not reader then
		error('Unsupported image format ' .. VTFObject.Formats[format] .. '!', 2)
	end

	if not istable(extra) then
		extra = {}
	end

	if extra.resources == nil then
		extra.resources = {}
	end

	if extra.flags == nil then
		extra.flags = 0
	end

	if extra.frames == nil then
		extra.frames = 1
	end

	if extra.first_frame == nil then
		extra.first_frame = 0
	end

	if extra.fill == nil then
		extra.fill = color_white
	end

	if extra.bumpmap_scale == nil then
		extra.bumpmap_scale = 1
	end

	if extra.mipmap_count == nil then
		extra.mipmap_count = 1
	elseif extra.mipmap_count == true then
		extra.mipmap_count = math.max(1, power_of_two[math.min(width, height)] - 1)
	elseif isnumber(extra.mipmap_count) and extra.mipmap_count < 0 then
		extra.mipmap_count = math.max(1, power_of_two[math.min(width, height)] + extra.mipmap_count)
	end

	if extra.depth == nil then
		extra.depth = 1
	end

	assert(isnumber(extra.flags), 'isnumber(extra.flags)', 2)
	assert(isnumber(extra.frames), 'isnumber(extra.frames)', 2)
	assert(isnumber(extra.first_frame), 'isnumber(extra.first_frame)', 2)
	assert(isnumber(extra.bumpmap_scale), 'isnumber(extra.bumpmap_scale)', 2)
	assert(isnumber(extra.mipmap_count), 'isnumber(extra.mipmap_count)', 2)
	assert(isnumber(extra.depth), 'isnumber(extra.depth)', 2)
	assert(power_of_two[extra.depth], 'extra.depth is not power of two', 2)
	assert(extra.frames >= 1, 'extra.frames >= 1', 2)
	assert(extra.first_frame >= 0, 'extra.first_frame >= 0', 2)
	assert(extra.mipmap_count >= 1, 'extra.mipmap_count >= 1', 2)
	assert(IsColor(extra.fill), 'IsColor(extra.fill)', 2)

	if extra.mipmap_count > power_of_two[math.min(width, height)] then
		error(string.format('Can not create image with %d mip levels due to image size of %dx%d', extra.mipmap_count, width, height), 2)
	end

	if extra.mipmap_count == 1 then
		extra.flags = extra.flags:bor(TEXTUREFLAGS_NOMIP, TEXTUREFLAGS_NOLOD)
	end

	if VTFObject.EightBitAlpha[VTFObject.Formats[format]] and not extra.force_no_eightbitalpha then
		extra.flags = extra.flags:bor(TEXTUREFLAGS_EIGHTBITALPHA)
	end

	if format == IMAGE_FORMAT_DXT1_ONEBITALPHA then
		extra.flags = extra.flags:bor(TEXTUREFLAGS_ONEBITALPHA)
	end

	extra.resources['\x01\x00\x00'] = nil
	extra.resources['\x30\x00\x00'] = nil

	local bytes = DLib.BytesBuffer('VTF\x00')
	bytes:Seek(4)

	bytes:WriteUInt32LE(7)
	bytes:WriteUInt32LE(version)
	local header_size_pos = bytes:Tell()
	bytes:WriteUInt32LE(0)

	bytes:WriteUInt16LE(width)
	bytes:WriteUInt16LE(height)

	bytes:WriteUInt32LE(extra.flags)
	bytes:WriteUInt16LE(extra.frames)
	bytes:WriteUInt16LE(extra.first_frame)

	bytes:WriteUInt32(0)

	bytes:WriteFloatLE(extra.fill.r / 255)
	bytes:WriteFloatLE(extra.fill.g / 255)
	bytes:WriteFloatLE(extra.fill.b / 255)

	bytes:WriteUInt32(0)
	bytes:WriteFloatLE(extra.bumpmap_scale)

	--bytes:WriteUInt32LE(format == IMAGE_FORMAT_DXT1_ONEBITALPHA and IMAGE_FORMAT_DXT1 or format)
	bytes:WriteUInt32LE(format)
	bytes:WriteUByte(extra.mipmap_count)

	bytes:WriteUInt32LE(VTFObject.Formats.IMAGE_FORMAT_DXT1)

	local thumb_width, thumb_height

	if width == height then
		thumb_width, thumb_height = 16, 16
	elseif width <= 16 and height <= 16 then
		thumb_width, thumb_height = width:max(4), height:max(4)
	elseif width < height then
		thumb_height = 16
		thumb_width = math.max(4, (width / height) * 16)
	else
		thumb_width = 16
		thumb_height = math.max(4, (height / width) * 16)
	end

	bytes:WriteUByte(thumb_width)
	bytes:WriteUByte(thumb_height)

	if version >= 2 then
		bytes:WriteUInt16LE(extra.depth)
	end

	local faces = bit.band(extra.flags, TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP and 6 or 1

	local resolutions = {}
	local w, h = width, height

	for mipmap = extra.mipmap_count, 1, -1 do
		resolutions[mipmap] = {w, h}
		w = w / 2
		h = h / 2
	end

	local num_resources = table.Count(extra.resources) + 2

	if version >= 3 then
		-- padding
		bytes:WriteUInt24LE(0)

		bytes:WriteUInt32LE(num_resources)

		-- padding
		bytes:WriteUInt32LE(0)
		bytes:WriteUInt32LE(0)

		-- reserve space for resources
		bytes:WriteBinary(string.rep('\x00', num_resources * (3 + 4 + 1)))
	end

	local size = bytes:Tell()

	-- achieved with SORSE
	-- 7.2 and lower appears to have mandatory padding for header to be 80 bytes
	-- but VTFLib properly read unpadded files
	if version <= 2 and size < 80 then
		bytes:WriteBinary(string.rep('\x00', 80 - size))
		size = bytes:Tell()
	end

	bytes:Seek(header_size_pos)
	bytes:WriteUInt32LE(size)
	bytes:Seek(size)

	if version >= 3 then
		bytes:Walk(-num_resources * (3 + 4 + 1))

		bytes:WriteBinary('\x01\x00\x00')
		bytes:WriteUByte(0)
		bytes:WriteUInt32LE(size)

		bytes:WriteBinary('\x30\x00\x00')
		bytes:WriteUByte(0)
		bytes:WriteUInt32LE(size + thumb_width * thumb_height / 2)

		local offset = size + thumb_width * thumb_height / 2

		for mipmap = 1, extra.mipmap_count do
			offset = offset + reader.CountBytes(resolutions[mipmap][1], resolutions[mipmap][2]) * extra.frames * faces
		end

		for k, v in SortedPairs(extra.resources) do
			if v.offset then
				bytes:WriteBinary(k)
				bytes:WriteUByte(v.flags or 0)
				bytes:WriteUInt32LE(v.offset)
			elseif isstring(v.data) then
				bytes:WriteBinary(k)
				bytes:WriteUByte(v.flags or 0)
				bytes:WriteUInt32LE(offset)
				offset = offset + #v.data
			else
				error('Unfinished resource entry at ' .. table.concat({string.byte(k, 1, 3)}, ' ') .. ' (neither offset or data present)')
			end
		end
	end

	-- write DXT1 thumbnail
	DLib.DXT1.Create(thumb_width, thumb_height, extra.fill, bytes)

	-- from smallest to largest
	for mipmap = 1, extra.mipmap_count do
		local w, h = resolutions[mipmap][1], resolutions[mipmap][2]

		-- from first to last
		for frame = 1, extra.frames do
			-- from first to last
			for face = 1, faces do
				-- for each Z slice (smallest to largest)
				for zDepth = 1, extra.depth do
					if format == IMAGE_FORMAT_DXT1_ONEBITALPHA then
						reader.Create(w, h, extra.fill, bytes, true)
					else
						reader.Create(w, h, extra.fill, bytes)
					end
				end
			end
		end
	end

	if version >= 3 then
		extra.resources['\x01\x00\x00'] = nil
		extra.resources['\x30\x00\x00'] = nil

		local offset = size + thumb_width * thumb_height / 2

		for mipmap = 1, extra.mipmap_count do
			offset = offset + reader.CountBytes(resolutions[mipmap][1], resolutions[mipmap][2]) * extra.frames * faces
		end

		bytes:Seek(offset)

		for k, v in SortedPairs(extra.resources) do
			if isstring(v.data) then
				bytes:WriteBinary(v.data)
			end
		end
	end

	bytes:Seek(0)
	return DLib.VTF(bytes)
end

--[[
	@doc
	@fname VTF:DecodeHiRes

	@internal
]]
function VTF:DecodeHiRes()
	-- from smallest to largest
	for mipmap = 1, self.mipmap_count do
		local w, h = self.mipmap_resolutions[mipmap][1], self.mipmap_resolutions[mipmap][2]
		self.structure[mipmap] = {}
		self.structure_buffer[mipmap] = {}

		-- from first to last
		for frame = 1, self.frames do
			self.structure[mipmap][frame] = {}
			self.structure_buffer[mipmap][frame] = {}

			-- from first to last
			for face = 1, self.faces do
				self.structure[mipmap][frame][face] = {}
				self.structure_buffer[mipmap][frame][face] = {}

				-- for each Z slice (smallest to largest)
				for zDepth = 1, self.depth do
					local walk = self.reader.CountBytes(w, h)

					self.structure_buffer[mipmap][frame][face][zDepth] = self.bytes:Slice(self.bytes:Tell(), walk)
					self.structure[mipmap][frame][face][zDepth] = self.reader(self.bytes, w, h)

					if self.high_res_image_format == IMAGE_FORMAT_DXT1_ONEBITALPHA then
						self.structure[mipmap][frame][face][zDepth]:SetOneBitAlpha(true)
					end

					if self.mipmaps[mipmap] == nil then
						self.mipmaps[mipmap] = self.structure_buffer[mipmap][frame][face][zDepth]
						self.mipmaps_obj[mipmap] = self.structure[mipmap][frame][face][zDepth]
					end

					self.bytes:Walk(walk)
				end
			end
		end
	end
end

--[[
	@doc
	@fname VTF:DecodeLowRes

	@internal
]]
function VTF:DecodeLowRes()
	-- DXT1: each block takes 64 bits of data, or 8 bytes
	-- width / 4 * height / 4 * 8
	-- skip it
	self.bytes:Walk(self.low_width * self.low_height / 2)
end

--[[
	@doc
	@fname DLib.VTF
	@args table bytesBuffer

	@desc
	this is a moonscript compatible class table
	Example usage: `DLib.VTF(DLib.BytesBuffer(file.Read('something.vtf', 'DATA')))`

	If you don't need to modify texture and only read it, use `DLib.ImmutableBytesBuffer` in example above.
	That will be a lot faster
	@enddesc

	@returns
	table: newly created DLib.VTF
]]
function VTF:ctor(bytes)
	self.pointer = bytes:Tell()
	self.bytes = bytes

	local readHead = VTFObject.HeaderStruct(bytes)
	local readHead2, readHead3

	if readHead.version[2] >= 2 then
		readHead2 = VTFObject.HeaderStruct72(bytes)
	end

	if readHead.version[2] >= 3 then
		readHead3 = VTFObject.HeaderStruct73(bytes)
	end

	self.version_string = string.format('%d.%d', readHead.version[1], readHead.version[2])

	self.version_major = readHead.version[1] -- 4
	self.version_minor = readHead.version[2] -- 8

	self.width = readHead.width -- 12
	self.height = readHead.height -- 14
	self.flags = readHead.flags -- 16
	self.frames = readHead.frames -- 20
	self.first_frame = readHead.firstFrame -- 22
	self.reflectivity = Vector(1 - readHead.reflectivity[1], 1 - readHead.reflectivity[2], 1 - readHead.reflectivity[3]) -- 28
	self.high_res_image_format = readHead.highResImageFormat
	self.low_res_image_format = readHead.lowResImageFormat
	self.low_width = readHead.lowResImageWidth
	self.low_height = readHead.lowResImageHeight
	self.mipmap_count = readHead.mipmapCount

	if readHead2 then
		self.depth = readHead2.depth
	else
		self.depth = 1
	end

	if readHead3 then
		self.num_resources = readHead3.numResources
	end

	self.faces = 1

	if bit.band(self.flags, TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP then
		self.faces = 6
	end

	assert(
		self.low_res_image_format == VTFObject.Formats.IMAGE_FORMAT_DXT1 or
		self.low_width == 0 and self.low_height == 0
	, 'self.low_res_image_format ~= VTFObject.Formats.IMAGE_FORMAT_DXT1 (' .. self.low_res_image_format .. ' ~= ' .. VTFObject.Formats.IMAGE_FORMAT_DXT1 .. ')')

	local resolutions = {}
	local w, h = self.width, self.height

	for mipmap = self.mipmap_count, 1, -1 do
		resolutions[mipmap] = {w, h}
		w = w / 2
		h = h / 2
	end

	self.mipmap_resolutions = resolutions

	-- first frame / first face
	self.mipmaps = {}
	self.mipmaps_obj = {}

	self.structure = {}
	self.structure_buffer = {}

	local reader = assert(VTFObject.Readers[VTFObject.Formats[self.high_res_image_format]], 'Unsupported image format ' .. VTFObject.Formats[self.high_res_image_format])
	self.reader = reader

	self.support_alpha = VTFObject.AlphaFormats[VTFObject.Formats[self.high_res_image_format]] == true

	if self.version_minor <= 2 then
		if bytes:Tell() < readHead.headerSize then
			bytes:Walk(readHead.headerSize - bytes:Tell())
		end

		self:DecodeLowRes()
		self:DecodeHiRes()
	else
		self.resources = {}

		for i = 1, self.num_resources do
			local resource = VTFObject.ResourceInfoStruct(bytes)

			if resource.tag[1] == 48 and resource.tag[2] == 0 and resource.tag[3] == 0 then
				self.resources.high_res = resource
			elseif resource.tag[1] == 1 and resource.tag[2] == 0 and resource.tag[3] == 0 then
				self.resources.low_res = resource
			elseif resource.tag[1] == 16 and resource.tag[2] == 0 and resource.tag[3] == 0 then
				self.resources.particle = resource
			else
				self.resources[string.char(resource.tag[1], resource.tag[2], resource.tag[3])] = resource
			end
		end

		if self.resources.low_res then
			bytes:Seek(self.pointer + self.resources.low_res.offset)
			self:DecodeLowRes()
		end

		if self.resources.high_res then
			bytes:Seek(self.pointer + self.resources.high_res.offset)
			self:DecodeHiRes()
		end
	end
end

--[[
	@doc
	@fname VTF:SetUpcomingMipmap
	@args number mipmap

	@desc
	Sets appropriate variable for upcoming operations as default value
	@enddesc
]]

--[[
	@doc
	@fname VTF:GetUpcomingMipmap
	@args number mipmap

	@returns
	number
]]
AccessorFunc(VTF, 'm_upcomping_mipmap', 'UpcomingMipmap')

--[[
	@doc
	@fname VTF:SetUpcomingFrame
	@args number frame

	@desc
	Sets appropriate variable for upcoming operations as default value
	1 count start based
	@enddesc
]]

--[[
	@doc
	@fname VTF:GetUpcomingFrame
	@args number frame

	@returns
	number
]]
AccessorFunc(VTF, 'm_upcomping_frame', 'UpcomingFrame')

--[[
	@doc
	@fname VTF:SetUpcomingFace
	@args number face

	@desc
	Sets appropriate variable for upcoming operations as default value
	1 count start based
	@enddesc
]]

--[[
	@doc
	@fname VTF:GetUpcomingFace
	@args number face

	@returns
	number
]]
AccessorFunc(VTF, 'm_upcomping_face', 'UpcomingFace')

--[[
	@doc
	@fname VTF:SetUpcomingDepth
	@args number depth

	@desc
	Sets appropriate variable for upcoming operations as default value
	1 count start based
	@enddesc
]]

--[[
	@doc
	@fname VTF:GetUpcomingDepth
	@args number depth

	@returns
	number
]]
AccessorFunc(VTF, 'm_upcomping_depth', 'UpcomingDepth')

--[[
	@doc
	@fname VTF:GetTexture
	@args number mipmap = 1, number frame = 1, number face = 1, number zDepth = 1

	@desc
	throws errors if no texture is found (due to bad arguments)
	@enddesc

	@returns
	table: respective texture object (DLib.AbstractTexture derative)
]]
-- for reasons of better use experience, 1 is largest mipmap
function VTF:GetTexture(mipmap, frame, face, zDepth)
	if mipmap == nil then mipmap = 1 end
	if frame == nil then frame = 1 end
	if face == nil then face = 1 end
	if zDepth == nil then zDepth = 1 end

	assert(isnumber(mipmap), 'isnumber(mipmap)')
	assert(isnumber(frame), 'isnumber(frame)')
	assert(isnumber(face), 'isnumber(face)')
	assert(isnumber(zDepth), 'isnumber(zDepth)')

	assert(mipmap >= 1 and mipmap <= self.mipmap_count, 'mipmap >= 1 and mipmap <= self.mipmap_count')
	assert(frame >= 1 and frame <= self.frames, 'frame >= 1 and frame <= self.frames')
	assert(face >= 1 and face <= self.faces, 'face >= 1 and face <= self.faces')
	assert(zDepth >= 1 and zDepth <= self.depth, 'zDepth >= 1 and zDepth <= self.depth')

	return self.structure[self.mipmap_count - mipmap + 1][frame][face][zDepth]
end

--[[
	@doc
	@fname VTF:ToFileStream
	@args File stream
]]
function VTF:ToFileStream(...)
	return self.bytes:ToFileStream(...)
end

--[[
	@doc
	@fname VTF:ToString

	@returns
	string: binary
]]
function VTF:ToString()
	return self.bytes:ToString()
end

local sample_encode_buff = {}

--[[
	@doc
	@fname VTF:AutoGenerateMips
	@args boolean supersample, table options = {}

	@desc
	Samples biggest mipmap onto all smaller mips.
	Supersampling is much more accurate when calculating very small mips,
	but is performance hungry, since it has to sample entire biggest mip each time.
	`options` might include:
	`coroutine` boolean (whenever to use coroutine, **set to true if not present and AutoGenerateMips called within coroutine**)
	`thresold` number (how long to execute on each coroutine.resume call)
	This also (re)calculate reflectivity
	@enddesc
]]
do
	local sample_buffer = {}
	local sample_result = {}

	for i = 1, 16 do
		sample_buffer[i] = {0, 0, 0, 255}
		sample_encode_buff[i] = {0, 0, 0, 255}
	end

	for i = 1, 4 do
		sample_result[i] = {0, 0, 0, 255}
	end

	local function SubsampleBlock(getblock)
		-- 0x0 texel
		local a, b, c, d = getblock[1], getblock[2], getblock[5], getblock[6]
		local obj = sample_result[1]

		obj[1] = (a[1] + b[1] + c[1] + d[1]) * 0.25
		obj[2] = (a[2] + b[2] + c[2] + d[2]) * 0.25
		obj[3] = (a[3] + b[3] + c[3] + d[3]) * 0.25
		obj[4] = (a[4] + b[4] + c[4] + d[4]) * 0.25

		-- 1x0
		a, b, c, d = getblock[3], getblock[4], getblock[7], getblock[8]
		obj = sample_result[2]

		obj[1] = (a[1] + b[1] + c[1] + d[1]) * 0.25
		obj[2] = (a[2] + b[2] + c[2] + d[2]) * 0.25
		obj[3] = (a[3] + b[3] + c[3] + d[3]) * 0.25
		obj[4] = (a[4] + b[4] + c[4] + d[4]) * 0.25

		-- 0x1
		a, b, c, d = getblock[9], getblock[10], getblock[13], getblock[14]
		obj = sample_result[3]

		obj[1] = (a[1] + b[1] + c[1] + d[1]) * 0.25
		obj[2] = (a[2] + b[2] + c[2] + d[2]) * 0.25
		obj[3] = (a[3] + b[3] + c[3] + d[3]) * 0.25
		obj[4] = (a[4] + b[4] + c[4] + d[4]) * 0.25

		-- 1x1
		a, b, c, d = getblock[11], getblock[12], getblock[15], getblock[16]
		obj = sample_result[4]

		obj[1] = (a[1] + b[1] + c[1] + d[1]) * 0.25
		obj[2] = (a[2] + b[2] + c[2] + d[2]) * 0.25
		obj[3] = (a[3] + b[3] + c[3] + d[3]) * 0.25
		obj[4] = (a[4] + b[4] + c[4] + d[4]) * 0.25
	end

	local function SampleBlock(getblock, result)
		local sampleR, sampleG, sampleB, sampleA = 0, 0, 0, 0

		for i = 1, 16 do
			local col = getblock[i]
			sampleR, sampleG, sampleB, sampleA = sampleR + col[1], sampleG + col[2], sampleB + col[3], sampleA + col[4]
		end

		result[1] = sampleR * 0.0625
		result[2] = sampleG * 0.0625
		result[3] = sampleB * 0.0625
		result[4] = sampleA * 0.0625
	end

	local function SampleBlockPlain(getblock)
		local sampleR, sampleG, sampleB, sampleA = 0, 0, 0, 0

		for i = 1, 16 do
			local col = getblock[i]
			sampleR, sampleG, sampleB, sampleA = sampleR + col[1], sampleG + col[2], sampleB + col[3], sampleA + col[4]
		end

		return sampleR * 0.0625, sampleG * 0.0625, sampleB * 0.0625, sampleA * 0.0625
	end

	local math_pow = math.pow
	local SysTime = SysTime

	local function SuperSampleBlock(sample_from, blockX, blockY, level, result)
		if level == 0 then
			if result then
				return SampleBlock(sample_from:GetBlock(blockX, blockY, sample_buffer), result)
			end

			return SampleBlockPlain(sample_from:GetBlock(blockX, blockY, sample_buffer))
		end

		local step = math_pow(2, level - 1)

		local a1, a2, a3, a4 = SuperSampleBlock(sample_from, blockX, blockY, level - 1)
		local b1, b2, b3, b4 = SuperSampleBlock(sample_from, blockX + step, blockY, level - 1)
		local c1, c2, c3, c4 = SuperSampleBlock(sample_from, blockX, blockY + step, level - 1)
		local d1, d2, d3, d4 = SuperSampleBlock(sample_from, blockX + step, blockY + step, level - 1)

		if result then
			result[1] = (a1 + b1 + c1 + d1) * 0.25
			result[2] = (a2 + b2 + c2 + d2) * 0.25
			result[3] = (a3 + b3 + c3 + d3) * 0.25
			result[4] = (a4 + b4 + c4 + d4) * 0.25

			return
		end

		return
			(a1 + b1 + c1 + d1) * 0.25,
			(a2 + b2 + c2 + d2) * 0.25,
			(a3 + b3 + c3 + d3) * 0.25,
			(a4 + b4 + c4 + d4) * 0.25
	end

	-- if fast - sample *previous* mip (so it sample only 4 texels of bigger mip)
	-- if supersample, then it sample biggest mip and as current mip become smaller, more texels are sampled

	-- also, auto generating mipmaps will also calculate reflectivity

	local coroutine_yield = coroutine.yield

	function VTF:AutoGenerateMips(supersample, opts, ...)
		if self.mipmap_count == 1 then return false end

		if not istable(opts) then
			opts = {
				coroutine = coroutine.running() ~= nil,
				thresold = 0.02,
			}
		end

		if opts.coroutine == nil then opts.coroutine = coroutine.running() ~= nil end
		if opts.thresold == nil then opts.thresold = 0.02 end

		local identifier

		if opts.before == nil and opts.after == nil then
			identifier = string.format('vtf_mips_%d', DLib._NEXT_VTF_PROGRESS_IDENTIFIER)
			DLib._NEXT_VTF_PROGRESS_IDENTIFIER = DLib._NEXT_VTF_PROGRESS_IDENTIFIER + 1
			local text = supersample and DLib.I18n.Localize('gui.dlib.notify.vtf_supersampling') or DLib.I18n.Localize('gui.dlib.notify.vtf_sampling')

			function opts.before()

			end

			function opts.after(progress)
				DLib.Util.PushProgress(identifier, text, progress)
			end
		end

		if opts.before == nil then opts.before = function() end end
		if opts.after == nil then opts.after = function() end end

		local _before, _after = opts.before, opts.after

		local use_coroutine = opts.coroutine
		local thresold = opts.thresold

		local sampling = 0
		local encoding = 0

		local sampleR, sampleG, sampleB, sampleA, samples = 0, 0, 0, 0, 0
		local reflectivity = true

		local scoroutine = SysTime() + thresold

		local tosample = 0
		local sampled = 0

		for mipmap = self.mipmap_count - 1, 1, -1 do
			for frame = 1, self.frames do
				for face = 1, self.faces do
					for zDepth = 1, self.depth do
						local current = self.structure[mipmap][frame][face][zDepth]
						tosample = tosample + current.width_blocks * current.height_blocks
					end
				end
			end
		end

		if supersample then
			local biggest = self.structure[self.mipmap_count]
			local sample_width = 1
			local supersample_level = 1
			local grid_width = 2

			-- from biggest to smallest
			for mipmap = self.mipmap_count - 1, 1, -1 do
				for frame = 1, self.frames do
					for face = 1, self.faces do
						for zDepth = 1, self.depth do
							local biggest = biggest[frame][face][zDepth]
							local current = self.structure[mipmap][frame][face][zDepth]

							local w, h = current.width_blocks, current.height_blocks

							-- sampling 2x2 blocks per 1 texel on mip texture
							-- so let's optimize that by sampling (4 blocks of 2x2 texels at once) * 4
							if supersample_level == 1 then
								for blockX = 0, w - 1 do
									for blockY = 0, h - 1 do
										local block = {}

										local s = SysTime()
										-- sampling 0x0 to 1x1
										SubsampleBlock(biggest:GetBlock(blockX * 2, blockY * 2, sample_buffer))
										local obj = sample_encode_buff[1]
										local obj2 = sample_result[1]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[2]
										obj2 = sample_result[2]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[5]
										obj2 = sample_result[3]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[6]
										obj2 = sample_result[4]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										-- sampling 2x0 to 3x1
										SubsampleBlock(biggest:GetBlock(blockX * 2 + 1, blockY * 2, sample_buffer))

										obj  = sample_encode_buff[3]
										obj2 = sample_result[1]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[4]
										obj2 = sample_result[2]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[7]
										obj2 = sample_result[3]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[8]
										obj2 = sample_result[4]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										-- sampling 0x2 to 1x2
										SubsampleBlock(biggest:GetBlock(blockX * 2, blockY * 2 + 1, sample_buffer))

										obj  = sample_encode_buff[9]
										obj2 = sample_result[1]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[10]
										obj2 = sample_result[2]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[13]
										obj2 = sample_result[3]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[14]
										obj2 = sample_result[4]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]


										-- sampling 2x2 to 3x3
										SubsampleBlock(biggest:GetBlock(blockX * 2 + 1, blockY * 2 + 1, sample_buffer))

										obj  = sample_encode_buff[11]
										obj2 = sample_result[1]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[12]
										obj2 = sample_result[2]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[15]
										obj2 = sample_result[3]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										obj  = sample_encode_buff[16]
										obj2 = sample_result[4]
										obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

										if reflectivity then
											for i = 1, 16 do
												local obj = sample_encode_buff[i]
												sampleR = sampleR + obj[1]
												sampleG = sampleG + obj[2]
												sampleB = sampleB + obj[3]
												sampleA = sampleA + obj[4]
											end

											samples = samples + 16
										end

										sampling = sampling + SysTime() - s

										s = SysTime()
										current:SetBlock(blockX, blockY, sample_encode_buff, true)
										encoding = encoding + SysTime() - s

										sampled = sampled + 1

										if use_coroutine and scoroutine <= SysTime() then
											_before()
											coroutine_yield(...)
											scoroutine = SysTime() + thresold
											_after(sampled / tosample)
										end
									end
								end

							-- sample entire blocks for one texel
							elseif supersample_level == 2 then
								for blockX = 0, w - 1 do
									for blockY = 0, h - 1 do
										local s = SysTime()
										SampleBlock(biggest:GetBlock(blockX * 4,       blockY * 4,     sample_buffer), sample_encode_buff[1 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 1,   blockY * 4,     sample_buffer), sample_encode_buff[2 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 2,   blockY * 4,     sample_buffer), sample_encode_buff[3 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 3,   blockY * 4,     sample_buffer), sample_encode_buff[4 ])
										SampleBlock(biggest:GetBlock(blockX * 4,       blockY * 4 + 1, sample_buffer), sample_encode_buff[5 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 1,   blockY * 4 + 1, sample_buffer), sample_encode_buff[6 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 2,   blockY * 4 + 1, sample_buffer), sample_encode_buff[7 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 3,   blockY * 4 + 1, sample_buffer), sample_encode_buff[8 ])
										SampleBlock(biggest:GetBlock(blockX * 4,       blockY * 4 + 2, sample_buffer), sample_encode_buff[9 ])
										SampleBlock(biggest:GetBlock(blockX * 4 + 1,   blockY * 4 + 2, sample_buffer), sample_encode_buff[10])
										SampleBlock(biggest:GetBlock(blockX * 4 + 2,   blockY * 4 + 2, sample_buffer), sample_encode_buff[11])
										SampleBlock(biggest:GetBlock(blockX * 4 + 3,   blockY * 4 + 2, sample_buffer), sample_encode_buff[12])
										SampleBlock(biggest:GetBlock(blockX * 4,       blockY * 4 + 3, sample_buffer), sample_encode_buff[13])
										SampleBlock(biggest:GetBlock(blockX * 4 + 1,   blockY * 4 + 3, sample_buffer), sample_encode_buff[14])
										SampleBlock(biggest:GetBlock(blockX * 4 + 2,   blockY * 4 + 3, sample_buffer), sample_encode_buff[15])
										SampleBlock(biggest:GetBlock(blockX * 4 + 3,   blockY * 4 + 3, sample_buffer), sample_encode_buff[16])

										if reflectivity then
											for i = 1, 16 do
												local obj = sample_encode_buff[i]
												sampleR = sampleR + obj[1]
												sampleG = sampleG + obj[2]
												sampleB = sampleB + obj[3]
												sampleA = sampleA + obj[4]
											end

											samples = samples + 16
										end

										sampling = sampling + SysTime() - s

										s = SysTime()
										current:SetBlock(blockX, blockY, sample_encode_buff, true)
										encoding = encoding + SysTime() - s

										sampled = sampled + 1

										if use_coroutine and scoroutine <= SysTime() then
											_before()
											coroutine_yield(...)
											scoroutine = SysTime() + thresold
											_after(sampled / tosample)
										end
									end
								end

							-- recursive supersampling
							else
								local step = math.pow(2, supersample_level)
								local step2 = math.pow(2, supersample_level - 2)

								for blockX = 0, w - 1 do
									for blockY = 0, h - 1 do
										local s = SysTime()

										SuperSampleBlock(biggest, blockX * step            , blockY * step            ,  supersample_level - 2, sample_encode_buff[1 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 1, blockY * step            ,  supersample_level - 2, sample_encode_buff[2 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 2, blockY * step            ,  supersample_level - 2, sample_encode_buff[3 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 3, blockY * step            ,  supersample_level - 2, sample_encode_buff[4 ])
										SuperSampleBlock(biggest, blockX * step            , blockY * step + step2 * 1,  supersample_level - 2, sample_encode_buff[5 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 1, blockY * step + step2 * 1,  supersample_level - 2, sample_encode_buff[6 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 2, blockY * step + step2 * 1,  supersample_level - 2, sample_encode_buff[7 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 3, blockY * step + step2 * 1,  supersample_level - 2, sample_encode_buff[8 ])
										SuperSampleBlock(biggest, blockX * step            , blockY * step + step2 * 2,  supersample_level - 2, sample_encode_buff[9 ])
										SuperSampleBlock(biggest, blockX * step + step2 * 1, blockY * step + step2 * 2,  supersample_level - 2, sample_encode_buff[10])
										SuperSampleBlock(biggest, blockX * step + step2 * 2, blockY * step + step2 * 2,  supersample_level - 2, sample_encode_buff[11])
										SuperSampleBlock(biggest, blockX * step + step2 * 3, blockY * step + step2 * 2,  supersample_level - 2, sample_encode_buff[12])
										SuperSampleBlock(biggest, blockX * step            , blockY * step + step2 * 3,  supersample_level - 2, sample_encode_buff[13])
										SuperSampleBlock(biggest, blockX * step + step2 * 1, blockY * step + step2 * 3,  supersample_level - 2, sample_encode_buff[14])
										SuperSampleBlock(biggest, blockX * step + step2 * 2, blockY * step + step2 * 3,  supersample_level - 2, sample_encode_buff[15])
										SuperSampleBlock(biggest, blockX * step + step2 * 3, blockY * step + step2 * 3,  supersample_level - 2, sample_encode_buff[16])

										if reflectivity then
											for i = 1, 16 do
												local obj = sample_encode_buff[i]
												sampleR = sampleR + obj[1]
												sampleG = sampleG + obj[2]
												sampleB = sampleB + obj[3]
												sampleA = sampleA + obj[4]
											end

											samples = samples + 16
										end

										sampling = sampling + SysTime() - s

										s = SysTime()
										current:SetBlock(blockX, blockY, sample_encode_buff, true)
										encoding = encoding + SysTime() - s

										sampled = sampled + 1

										if use_coroutine and scoroutine <= SysTime() then
											_before()
											coroutine_yield(...)
											scoroutine = SysTime() + thresold
											_after(sampled / tosample)
										end
									end
								end
							end

							if reflectivity then
								reflectivity = false
							end
						end
					end
				end

				supersample_level = supersample_level + 1
				sample_width = sample_width * 2
				grid_width = grid_width * 2
			end
		else
			-- from biggest to smallest
			for mipmap = self.mipmap_count - 1, 1, -1 do
				for frame = 1, self.frames do
					for face = 1, self.faces do
						for zDepth = 1, self.depth do
							local prev = self.structure[mipmap + 1][frame][face][zDepth]
							local current = self.structure[mipmap][frame][face][zDepth]

							local w, h = current.width_blocks, current.height_blocks

							for blockX = 0, w - 1 do
								for blockY = 0, h - 1 do
									local block = {}

									local s = SysTime()
									-- sampling 0x0 to 1x1
									SubsampleBlock(prev:GetBlock(blockX * 2, blockY * 2, sample_buffer))
									local obj = sample_encode_buff[1]
									local obj2 = sample_result[1]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[2]
									obj2 = sample_result[2]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[5]
									obj2 = sample_result[3]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[6]
									obj2 = sample_result[4]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									-- sampling 2x0 to 3x1
									SubsampleBlock(prev:GetBlock(blockX * 2 + 1, blockY * 2, sample_buffer))

									obj  = sample_encode_buff[3]
									obj2 = sample_result[1]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[4]
									obj2 = sample_result[2]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[7]
									obj2 = sample_result[3]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[8]
									obj2 = sample_result[4]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									-- sampling 0x2 to 1x2
									SubsampleBlock(prev:GetBlock(blockX * 2, blockY * 2 + 1, sample_buffer))

									obj  = sample_encode_buff[9]
									obj2 = sample_result[1]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[10]
									obj2 = sample_result[2]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[13]
									obj2 = sample_result[3]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[14]
									obj2 = sample_result[4]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									-- sampling 2x2 to 3x3
									SubsampleBlock(prev:GetBlock(blockX * 2 + 1, blockY * 2 + 1, sample_buffer))

									obj  = sample_encode_buff[11]
									obj2 = sample_result[1]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[12]
									obj2 = sample_result[2]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[15]
									obj2 = sample_result[3]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									obj  = sample_encode_buff[16]
									obj2 = sample_result[4]
									obj[1], obj[2], obj[3], obj[4] = obj2[1], obj2[2], obj2[3], obj2[4]

									if reflectivity then
										for i = 1, 16 do
											local obj = sample_encode_buff[i]
											sampleR = sampleR + obj[1]
											sampleG = sampleG + obj[2]
											sampleB = sampleB + obj[3]
											sampleA = sampleA + obj[4]
										end

										samples = samples + 16
									end

									sampling = sampling + SysTime() - s

									s = SysTime()
									current:SetBlock(blockX, blockY, sample_encode_buff, true)
									encoding = encoding + SysTime() - s

									sampled = sampled + 1

									if use_coroutine and scoroutine <= SysTime() then
										_before()
										coroutine_yield(...)
										scoroutine = SysTime() + thresold
										_after(sampled / tosample)
									end
								end
							end

							if reflectivity then
								reflectivity = false
							end
						end
					end
				end
			end
		end

		local mult = sampleA / (samples * samples) * 1.5378700499808e-05
		local reflectivity = Vector(sampleR * mult, sampleG * mult, sampleB * mult)
		self.reflectivity = reflectivity

		local bytes = self.bytes

		bytes:Seek(self.pointer + 32)

		bytes:WriteFloatLE(reflectivity.x)
		bytes:WriteFloatLE(reflectivity.y)
		bytes:WriteFloatLE(reflectivity.z)

		if identifier then
			DLib.Util.PopProgress(identifier)
		end

		return true, sampling, encoding
	end
end

--[[
	@doc
	@fname VTF:CalculateReflectivity
]]
function VTF:CalculateReflectivity()
	local obj = self.mipmaps_obj[self.mipmap_count]

	local sampleR, sampleG, sampleB, sampleA = 0, 0, 0, 0

	for blockX = 0, obj.width_blocks - 1 do
		for blockY = 0, obj.height_blocks - 1 do
			obj:GetBlock(blockX, blockY, sample_encode_buff)

			for i = 1, 16 do
				local obj = sample_encode_buff[i]
				sampleR = sampleR + obj[1]
				sampleG = sampleG + obj[2]
				sampleB = sampleB + obj[3]
				sampleA = sampleA + obj[4]
			end
		end
	end

	local mult = sampleA / (obj.width * obj.height * obj.width * obj.height) * 1.5378700499808e-05
	local reflectivity = Vector(sampleR * mult, sampleG * mult, sampleB * mult)
	self:SetReflectivity(reflectivity)
end

--[[
	@doc
	@fname VTF:SetFlags
	@args number flags

	@desc
	certain flags that mutate texture depth/faces are immutable
	@enddesc

	@returns
	table: self
]]
function VTF:SetFlags(flags)
	assert(isnumber(flags), 'isnumber(flags)')

	if flags:band(TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP and self.flags:band(TEXTUREFLAGS_ENVMAP) == 0 then
		error('Can not add TEXTUREFLAGS_ENVMAP to existing texture')
	elseif flags:band(TEXTUREFLAGS_ENVMAP) == 0 and self.flags:band(TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP then
		error('Can not remove TEXTUREFLAGS_ENVMAP from existing texture')
	end

	self.bytes:Seek(self.pointer + 20)
	self.bytes:WriteUInt32LE(flags)
	self.flags = flags

	return self
end

--[[
	@doc
	@fname VTF:AddFlags
	@args number flags

	@desc
	certain flags that mutate texture depth/faces are immutable
	@enddesc

	@returns
	table: self
]]
function VTF:AddFlags(flags)
	return self:SetFlags(self.flags:bor(flags))
end

--[[
	@doc
	@fname VTF:GetFlags

	@returns
	number: flags
]]
function VTF:GetFlags()
	return self.flags
end

--[[
	@doc
	@fname VTF:GetBytesBuffer

	@returns
	table: DLib.BytesBuffer/ImmutableBytesBuffer
]]
function VTF:GetBytesBuffer()
	return self.bytes
end

--[[
	@doc
	@fname VTF:RemoveFlags
	@args number flags

	@desc
	certain flags that mutate texture depth/faces are immutable
	@enddesc

	@returns
	table: self
]]
function VTF:RemoveFlags(flags)
	return self:SetFlags(self.flags:band(flags:bnot()))
end

--[[
	@doc
	@fname VTF:SetReflectivity
	@args Vector reflectivity

	@desc
	writes vector components as little endians to buffer to reflectivity
	variable in header
	@enddesc

	@returns
	table: self
]]
function VTF:SetReflectivity(reflectivity)
	self.reflectivity = reflectivity

	local bytes = self.bytes
	bytes:Seek(self.pointer + 32)
	bytes:WriteFloatLE(reflectivity.x)
	bytes:WriteFloatLE(reflectivity.y)
	bytes:WriteFloatLE(reflectivity.z)

	return self
end

--[[
	@doc
	@fname VTF:CaptureRenderTarget
	@args table options = {}

	@desc
	`options.x` number
	`options.y` number
	`options.width` number
	`options.height` number
	`options.rx` number (offset inside texture)
	`options.ry` number (offset inside texture)
	`options.mipmap` number (mipmap to use, starting from 1)
	`options.frame` number (frame to use, starting from 1)
	`options.face` number (face to use, starting from 1)
	`options.depth` number (depth to use, starting from 1)
	@enddesc

	@returns
	boolean: if the operation is supposely successful
]]
function VTF:CaptureRenderTarget(opts, y, width, height, rx, ry)
	if SERVER then error('Invalid realm', 2) end
	if not istable(opts) then
		opts = {
			x = opts,
			y = y,
			width = width,
			height = height,
			rx = rx,
			ry = ry,
		}
	end

	if opts.x == nil then opts.x = 0 end
	if opts.y == nil then opts.y = 0 end
	if opts.rx == nil then opts.rx = 0 end
	if opts.ry == nil then opts.ry = 0 end
	if opts.width == nil then opts.width = math.min(ScrW() - opts.rx, self.width - 1) end
	if opts.height == nil then opts.height = math.min(ScrH() - opts.ry, self.height - 1) end

	assert(opts.rx + opts.width < self.width, 'x + width < self.width')
	assert(opts.ry + opts.height < self.height, 'y + height < self.height')

	render.CapturePixels()
	local texture = self:GetTexture(opts.mipmap or self.m_upcomping_mipmap, opts.frame or self.m_upcomping_frame, opts.face or self.m_upcomping_face, opts.depth or self.m_upcomping_depth)
	texture:CaptureRenderTarget(opts.x, opts.y, opts.width, opts.height, opts.rx, opts.ry, opts.before, opts.after, opts.thersold)

	return true
end

--[[
	@doc
	@fname VTF:CaptureRenderTargetCoroutine
	@args table options = {}

	@desc
	`options.x` number
	`options.y` number
	`options.width` number
	`options.height` number
	`options.rx` number (offset inside texture)
	`options.ry` number (offset inside texture)
	`options.mipmap` number (mipmap to use, starting from 1)
	`options.frame` number (frame to use, starting from 1)
	`options.face` number (face to use, starting from 1)
	`options.depth` number (depth to use, starting from 1)
	`options.yield_args` table
	`options.thersold` number (how long to execute on each coroutine.resume call)
	`options.before` function (code to execute before coroutine.yield())
	`options.after` function (code to execute after coroutine.yield())
	if `before` and `after` are nil, they are defined as `render.Pop/PushRenderTarget`
	with `DLib.Util.PushProgress`
	@enddesc

	@returns
	boolean: if the operation is supposely successful
]]
function VTF:CaptureRenderTargetCoroutine(opts, y, width, height, rx, ry, ...)
	if SERVER then error('Invalid realm', 2) end
	if not istable(opts) then
		opts = {
			x = opts,
			y = y,
			width = width,
			height = height,
			rx = rx,
			ry = ry,
			yield_args = {...}
		}
	end

	if opts.x == nil then opts.x = 0 end
	if opts.y == nil then opts.y = 0 end
	if opts.rx == nil then opts.rx = 0 end
	if opts.ry == nil then opts.ry = 0 end
	if opts.width == nil then opts.width = math.min(ScrW() - opts.rx, self.width - 1) end
	if opts.height == nil then opts.height = math.min(ScrH() - opts.ry, self.height - 1) end

	local identifier

	if opts.before == nil and opts.after == nil then
		local rt = render.GetRenderTarget()
		identifier = string.format('vtf_rt_%d', DLib._NEXT_VTF_PROGRESS_IDENTIFIER)
		DLib._NEXT_VTF_PROGRESS_IDENTIFIER = DLib._NEXT_VTF_PROGRESS_IDENTIFIER + 1
		local text = DLib.I18n.Localize('gui.dlib.notify.vtf_encoding')

		function opts.before()
			-- idk
			render.PopRenderTarget()
		end

		function opts.after(progress)
			-- idk
			render.PushRenderTarget(rt)
			DLib.Util.PushProgress(identifier, text, progress)
		end
	end

	if opts.before == nil then opts.before = function() end end
	if opts.after == nil then opts.after = function() end end
	if opts.yield_args == nil then opts.yield_args = {} end
	if opts.thersold == nil then opts.thersold = 0.02 end

	assert(opts.rx + opts.width < self.width, 'x + width < self.width')
	assert(opts.ry + opts.height < self.height, 'y + height < self.height')

	local bitmap = render.CapturePixelsBitmap()
	local bW, bH = ScrW(), ScrH()
	local texture = self:GetTexture(opts.mipmap or self.m_upcomping_mipmap, opts.frame or self.m_upcomping_frame, opts.face or self.m_upcomping_face, opts.depth or self.m_upcomping_depth)
	texture:CaptureRenderTargetCoroutine(bitmap, bW, bH, opts.x, opts.y, opts.width, opts.height, opts.rx, opts.ry, opts.before, opts.after, opts.thersold, unpack(opts.yield_args))

	if identifier then
		DLib.Util.PopProgress(identifier)
	end

	return true
end

--[[
	@doc
	@fname VTF:CaptureRenderTargetAsAlpha
	@args table options = {}

	@desc
	Captures render target as "alpha"
	Fully white - opaque
	Fully black - translucent
	This is mostly required for getting Alpha on older gmod versions
	See https://github.com/Facepunch/garrysmod-requests/issues/1813
	`options.x` number
	`options.y` number
	`options.width` number
	`options.height` number
	`options.rx` number (offset inside texture)
	`options.ry` number (offset inside texture)
	`options.mipmap` number (mipmap to use, starting from 1)
	`options.frame` number (frame to use, starting from 1)
	`options.face` number (face to use, starting from 1)
	`options.depth` number (depth to use, starting from 1)
	@enddesc

	@returns
	boolean: if the operation is supposely successful
]]
-- captures current render target as "alpha"
-- fully white - means fully opaque
-- fully black - means fully translucent
-- R, G, B are equal and their sum is divided by 3
function VTF:CaptureRenderTargetAsAlpha(opts, y, width, height, rx, ry)
	if SERVER then error('Invalid realm', 2) end
	if not self.support_alpha then return false end

	if not istable(opts) then
		opts = {
			x = opts,
			y = y,
			width = width,
			height = height,
			rx = rx,
			ry = ry,
		}
	end

	if opts.x == nil then opts.x = 0 end
	if opts.y == nil then opts.y = 0 end
	if opts.rx == nil then opts.rx = 0 end
	if opts.ry == nil then opts.ry = 0 end
	if opts.width == nil then opts.width = math.min(ScrW() - opts.rx, self.width - 1) end
	if opts.height == nil then opts.height = math.min(ScrH() - opts.ry, self.height - 1) end

	assert(opts.rx + opts.width < self.width, 'x + width < self.width')
	assert(opts.ry + opts.height < self.height, 'y + height < self.height')

	render.CapturePixels()
	local texture = self:GetTexture(opts.mipmap or self.m_upcomping_mipmap, opts.frame or self.m_upcomping_frame, opts.face or self.m_upcomping_face, opts.depth or self.m_upcomping_depth)
	texture:CaptureRenderTargetAlpha(opts.x, opts.y, opts.width, opts.height, opts.rx, opts.ry, opts.before, opts.after, opts.thersold)

	return true
end

--[[
	@doc
	@fname VTF:CaptureRenderTargetAsAlphaCoroutine
	@args table options = {}

	@desc
	Captures render target as "alpha"
	Fully white - opaque
	Fully black - translucent
	This is mostly required for getting Alpha on older gmod versions
	See https://github.com/Facepunch/garrysmod-requests/issues/1813
	`options.x` number
	`options.y` number
	`options.width` number
	`options.height` number
	`options.rx` number (offset inside texture)
	`options.ry` number (offset inside texture)
	`options.mipmap` number (mipmap to use, starting from 1)
	`options.frame` number (frame to use, starting from 1)
	`options.face` number (face to use, starting from 1)
	`options.depth` number (depth to use, starting from 1)
	`options.yield_args` table
	`options.thersold` number (how long to execute on each coroutine.resume call)
	`options.before` function (code to execute before coroutine.yield())
	`options.after` function (code to execute after coroutine.yield())
	if `before` and `after` are nil, they are defined as `render.Pop/PushRenderTarget`
	with `DLib.Util.PushProgress`
	@enddesc

	@returns
	boolean: if the operation is supposely successful
]]
function VTF:CaptureRenderTargetAsAlphaCoroutine(opts, y, width, height, rx, ry, ...)
	if SERVER then error('Invalid realm', 2) end
	if not self.support_alpha then return false end

	if not istable(opts) then
		opts = {
			x = opts,
			y = y,
			width = width,
			height = height,
			rx = rx,
			ry = ry,
			yield_args = {...}
		}
	end

	if opts.x == nil then opts.x = 0 end
	if opts.y == nil then opts.y = 0 end
	if opts.rx == nil then opts.rx = 0 end
	if opts.ry == nil then opts.ry = 0 end
	if opts.width == nil then opts.width = math.min(ScrW() - opts.rx, self.width - 1) end
	if opts.height == nil then opts.height = math.min(ScrH() - opts.ry, self.height - 1) end

	local identifier

	if opts.before == nil and opts.after == nil then
		local rt = render.GetRenderTarget()
		identifier = string.format('vtf_rta_%d', DLib._NEXT_VTF_PROGRESS_IDENTIFIER)
		DLib._NEXT_VTF_PROGRESS_IDENTIFIER = DLib._NEXT_VTF_PROGRESS_IDENTIFIER + 1
		local text = DLib.I18n.Localize('gui.dlib.notify.vtf_encoding_alpha')

		function opts.before()
			render.PopRenderTarget()
		end

		function opts.after(progress)
			render.PushRenderTarget(rt)
			DLib.Util.PushProgress(identifier, text, progress)
		end
	end

	if opts.before == nil then opts.before = function() end end
	if opts.after == nil then opts.after = function() end end
	if opts.yield_args == nil then opts.yield_args = {} end
	if opts.thersold == nil then opts.thersold = 0.02 end

	assert(opts.rx + opts.width < self.width, 'x + width < self.width')
	assert(opts.ry + opts.height < self.height, 'y + height < self.height')

	local bitmap = render.CapturePixelsBitmap()
	local bW, bH = ScrW(), ScrH()
	local texture = self:GetTexture(opts.mipmap or self.m_upcomping_mipmap, opts.frame or self.m_upcomping_frame, opts.face or self.m_upcomping_face, opts.depth or self.m_upcomping_depth)
	texture:CaptureRenderTargetAlphaCoroutine(bitmap, bW, bH, opts.x, opts.y, opts.width, opts.height, opts.rx, opts.ry, opts.before, opts.after, opts.thersold, unpack(opts.yield_args))

	if identifier then
		DLib.Util.PopProgress(identifier)
	end

	return true
end

VTFObject.HeaderStruct = DLib.BytesBuffer.CompileStructure([[
	char                            signature[4];       // File signature ("VTF\0"). (or as little-endian integer, 0x00465456)
	little endian unsigned int      version[2];         // version[0].version[1] (currently 7.2).
	little endian unsigned int      headerSize;         // Size of the header struct  (16 byte aligned; currently 80 bytes) + size of the resources dictionary (7.3+).
	little endian unsigned short    width;              // Width of the largest mipmap in pixels. Must be a power of 2.
	little endian unsigned short    height;             // Height of the largest mipmap in pixels. Must be a power of 2.
	little endian unsigned int      flags;              // VTF flags.
	little endian unsigned short    frames;             // Number of frames, if animated (1 for no animation).
	little endian unsigned short    firstFrame;         // First frame in animation (0 based).
	unsigned char                   padding0[4];        // reflectivity padding (16 byte alignment).
	little endian float                           reflectivity[3];    // reflectivity vector.
	unsigned char                   padding1[4];        // reflectivity padding (8 byte packing).
	little endian float                           bumpmapScale;       // Bumpmap scale.
	little endian unsigned int      highResImageFormat; // High resolution image format.
	unsigned char                   mipmapCount;        // Number of mipmaps.
	little endian unsigned int      lowResImageFormat;  // Low resolution image format (always DXT1).
	unsigned char                   lowResImageWidth;   // Low resolution image width.
	unsigned char                   lowResImageHeight;  // Low resolution image height.
]])

VTFObject.HeaderStruct72 = DLib.BytesBuffer.CompileStructure([[
	// 7.2+
	little endian unsigned short    depth;              // Depth of the largest mipmap in pixels.
														// Must be a power of 2. Is 1 for a 2D texture.
]])

VTFObject.HeaderStruct73 = DLib.BytesBuffer.CompileStructure([[
	// 7.3+
	little endian unsigned char     padding2[3];        // depth padding (4 byte alignment).
	little endian unsigned int      numResources;       // Number of resources this vtf has. The max appears to be 32.

	little endian unsigned char     padding3[8];        // Necessary on certain compilers
]])

VTFObject.ResourceInfoStruct = DLib.BytesBuffer.CompileStructure([[
	unsigned char                   tag[3];             // A three-byte "tag" that identifies what this resource is.
	unsigned char                   flags;              // Resource entry flags. The only known flag is 0x2, which indicates that no data chunk corresponds to this resource.
	little endian unsigned int      offset;             // The offset of this resource's data in the file.
]])

DLib.VTF = DLib.CreateMoonClassBare('VTF', VTF, VTFObject)
