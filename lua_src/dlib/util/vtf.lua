
-- Copyright (C) 2017-2020 DBotThePony

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do so,
-- subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all copies
-- or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
-- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
-- PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
-- FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-- DEALINGS IN THE SOFTWARE.

_G.TEXTUREFLAGS_POINTSAMPLE                   = 0x00000001
_G.TEXTUREFLAGS_TRILINEAR                     = 0x00000002
_G.TEXTUREFLAGS_CLAMPS                        = 0x00000004
_G.TEXTUREFLAGS_CLAMPT                        = 0x00000008
_G.TEXTUREFLAGS_ANISOTROPIC                   = 0x00000010
_G.TEXTUREFLAGS_HINT_DXT5                     = 0x00000020
_G.TEXTUREFLAGS_SRGB                          = 0x00000040
_G.TEXTUREFLAGS_NORMAL                        = 0x00000080
_G.TEXTUREFLAGS_NOMIP                         = 0x00000100
_G.TEXTUREFLAGS_NOLOD                         = 0x00000200
_G.TEXTUREFLAGS_ALL_MIPS                      = 0x00000400
_G.TEXTUREFLAGS_PROCEDURAL                    = 0x00000800

-- These are automatically generated by vtex from the texture data.
_G.TEXTUREFLAGS_ONEBITALPHA                   = 0x00001000
_G.TEXTUREFLAGS_EIGHTBITALPHA                 = 0x00002000

-- newer flags from the *.txt config file
_G.TEXTUREFLAGS_ENVMAP                        = 0x00004000
_G.TEXTUREFLAGS_RENDERTARGET                  = 0x00008000
_G.TEXTUREFLAGS_DEPTHRENDERTARGET             = 0x00010000
_G.TEXTUREFLAGS_NODEBUGOVERRIDE               = 0x00020000
_G.TEXTUREFLAGS_SINGLECOPY                    = 0x00040000
_G.TEXTUREFLAGS_STAGING_MEMORY                = 0x00080000
_G.TEXTUREFLAGS_IMMEDIATE_CLEANUP             = 0x00100000
_G.TEXTUREFLAGS_IGNORE_PICMIP                 = 0x00200000
_G.TEXTUREFLAGS_UNUSED_00400000               = 0x00400000
_G.TEXTUREFLAGS_NODEPTHBUFFER                 = 0x00800000
_G.TEXTUREFLAGS_UNUSED_01000000               = 0x01000000
_G.TEXTUREFLAGS_CLAMPU                        = 0x02000000
_G.TEXTUREFLAGS_VERTEXTEXTURE                 = 0x04000000                 -- Useable as a vertex texture
_G.TEXTUREFLAGS_SSBUMP                        = 0x08000000
_G.TEXTUREFLAGS_UNUSED_10000000               = 0x10000000

-- Clamp to border color on all texture coordinates
_G.TEXTUREFLAGS_BORDER                        = 0x20000000
_G.TEXTUREFLAGS_UNUSED_40000000               = 0x40000000
_G.TEXTUREFLAGS_UNUSED_80000000               = 0x80000000

local TEXTUREFLAGS_POINTSAMPLE =       TEXTUREFLAGS_POINTSAMPLE
local TEXTUREFLAGS_TRILINEAR =         TEXTUREFLAGS_TRILINEAR
local TEXTUREFLAGS_CLAMPS =            TEXTUREFLAGS_CLAMPS
local TEXTUREFLAGS_CLAMPT =            TEXTUREFLAGS_CLAMPT
local TEXTUREFLAGS_ANISOTROPIC =       TEXTUREFLAGS_ANISOTROPIC
local TEXTUREFLAGS_HINT_DXT5 =         TEXTUREFLAGS_HINT_DXT5
local TEXTUREFLAGS_SRGB =              TEXTUREFLAGS_SRGB
local TEXTUREFLAGS_NORMAL =            TEXTUREFLAGS_NORMAL
local TEXTUREFLAGS_NOMIP =             TEXTUREFLAGS_NOMIP
local TEXTUREFLAGS_NOLOD =             TEXTUREFLAGS_NOLOD
local TEXTUREFLAGS_ALL_MIPS =          TEXTUREFLAGS_ALL_MIPS
local TEXTUREFLAGS_PROCEDURAL =        TEXTUREFLAGS_PROCEDURAL
local TEXTUREFLAGS_ONEBITALPHA =       TEXTUREFLAGS_ONEBITALPHA
local TEXTUREFLAGS_EIGHTBITALPHA =     TEXTUREFLAGS_EIGHTBITALPHA
local TEXTUREFLAGS_ENVMAP =            TEXTUREFLAGS_ENVMAP
local TEXTUREFLAGS_RENDERTARGET =      TEXTUREFLAGS_RENDERTARGET
local TEXTUREFLAGS_DEPTHRENDERTARGET = TEXTUREFLAGS_DEPTHRENDERTARGET
local TEXTUREFLAGS_NODEBUGOVERRIDE =   TEXTUREFLAGS_NODEBUGOVERRIDE
local TEXTUREFLAGS_SINGLECOPY =        TEXTUREFLAGS_SINGLECOPY
local TEXTUREFLAGS_STAGING_MEMORY =    TEXTUREFLAGS_STAGING_MEMORY
local TEXTUREFLAGS_IMMEDIATE_CLEANUP = TEXTUREFLAGS_IMMEDIATE_CLEANUP
local TEXTUREFLAGS_IGNORE_PICMIP =     TEXTUREFLAGS_IGNORE_PICMIP
local TEXTUREFLAGS_UNUSED_00400000 =   TEXTUREFLAGS_UNUSED_00400000
local TEXTUREFLAGS_NODEPTHBUFFER =     TEXTUREFLAGS_NODEPTHBUFFER
local TEXTUREFLAGS_UNUSED_01000000 =   TEXTUREFLAGS_UNUSED_01000000
local TEXTUREFLAGS_CLAMPU =            TEXTUREFLAGS_CLAMPU
local TEXTUREFLAGS_VERTEXTEXTURE =     TEXTUREFLAGS_VERTEXTEXTURE
local TEXTUREFLAGS_SSBUMP =            TEXTUREFLAGS_SSBUMP
local TEXTUREFLAGS_UNUSED_10000000 =   TEXTUREFLAGS_UNUSED_10000000
local TEXTUREFLAGS_BORDER =            TEXTUREFLAGS_BORDER
local TEXTUREFLAGS_UNUSED_40000000 =   TEXTUREFLAGS_UNUSED_40000000
local TEXTUREFLAGS_UNUSED_80000000 =   TEXTUREFLAGS_UNUSED_80000000


local VTF = {}
local VTFObject = {}

local Formats = {
	'IMAGE_FORMAT_NONE',
	'IMAGE_FORMAT_RGBA8888',
	'IMAGE_FORMAT_ABGR8888',
	'IMAGE_FORMAT_RGB888',
	'IMAGE_FORMAT_BGR888',
	'IMAGE_FORMAT_RGB565',
	'IMAGE_FORMAT_I8',
	'IMAGE_FORMAT_IA88',
	'IMAGE_FORMAT_P8',
	'IMAGE_FORMAT_A8',
	'IMAGE_FORMAT_RGB888_BLUESCREEN',
	'IMAGE_FORMAT_BGR888_BLUESCREEN',
	'IMAGE_FORMAT_ARGB8888',
	'IMAGE_FORMAT_BGRA8888',
	'IMAGE_FORMAT_DXT1',
	'IMAGE_FORMAT_DXT3',
	'IMAGE_FORMAT_DXT5',
	'IMAGE_FORMAT_BGRX8888',
	'IMAGE_FORMAT_BGR565',
	'IMAGE_FORMAT_BGRX5551',
	'IMAGE_FORMAT_BGRA4444',
	'IMAGE_FORMAT_DXT1_ONEBITALPHA',
	'IMAGE_FORMAT_BGRA5551',
	'IMAGE_FORMAT_UV88',
	'IMAGE_FORMAT_UVWQ8888',
	'IMAGE_FORMAT_RGBA16161616F',
	'IMAGE_FORMAT_RGBA16161616',
	'IMAGE_FORMAT_UVLX8888'
}

VTFObject.Formats = {}

for i = 1, #Formats do
	VTFObject.Formats[Formats[i]] = i - 2
	VTFObject.Formats[i - 2] = Formats[i]

	_G[Formats[i]] = i - 2
end

VTFObject.Readers = {}
VTFObject.Readers.IMAGE_FORMAT_DXT1 = DLib.DXT1
VTFObject.Readers.IMAGE_FORMAT_DXT3 = DLib.DXT3
VTFObject.Readers.IMAGE_FORMAT_DXT5 = DLib.DXT5

local color_white = Color()

local power_of_two = {}

for i = 0, 14 do
	power_of_two[math.pow(2, i)] = i
end

-- version is a number from 1 (7.1) to 5 (7.5)
function VTFObject.Create(version, width, height, format, extra)
	assert(isnumber(version), 'isnumber(version)', 2)
	version = version:floor()
	assert(version >= 1 and version <= 5, 'version does not belong to [1, 5] interval', 2)

	assert(isnumber(width), 'isnumber(width)', 2)
	assert(isnumber(height), 'isnumber(height)', 2)
	assert(power_of_two[width], 'Width is not power of two', 2)
	assert(power_of_two[height], 'Height is not power of two', 2)

	if isstring(format) then
		format = assert(VTFObject.Formats[format], 'Invalid format ' .. format .. '!', 2)
	elseif not VTFObject.Formats[format] then
		error('Invalid format index ' .. format .. '!', 2)
	end

	local reader = VTFObject.Readers[VTFObject.Formats[format]]
	if not reader then
		error('Unsupported image format ' .. VTFObject.Formats[format] .. '!', 2)
	end

	if not istable(extra) then
		extra = {}
	end

	if extra.flags == nil then
		extra.flags = 0
	end

	if extra.frames == nil then
		extra.frames = 1
	end

	if extra.first_frame == nil then
		extra.first_frame = 0
	end

	if extra.fill == nil then
		extra.fill = color_white
	end

	if extra.bumpmap_scale == nil then
		extra.bumpmap_scale = 1
	end

	if extra.mipmap_count == nil then
		extra.mipmap_count = 1
	elseif extra.mipmap_count == true then
		extra.mipmap_count = math.max(1, power_of_two[math.min(width, height)] - 1)
	elseif isnumber(extra.mipmap_count) and extra.mipmap_count < 0 then
		extra.mipmap_count = math.max(1, power_of_two[math.min(width, height)] + extra.mipmap_count)
	end

	if extra.depth == nil then
		extra.depth = 1
	end

	assert(isnumber(extra.flags), 'isnumber(extra.flags)', 2)
	assert(isnumber(extra.frames), 'isnumber(extra.frames)', 2)
	assert(isnumber(extra.first_frame), 'isnumber(extra.first_frame)', 2)
	assert(isnumber(extra.bumpmap_scale), 'isnumber(extra.bumpmap_scale)', 2)
	assert(isnumber(extra.mipmap_count), 'isnumber(extra.mipmap_count)', 2)
	assert(isnumber(extra.depth), 'isnumber(extra.depth)', 2)
	assert(power_of_two[extra.depth], 'extra.depth is not power of two', 2)
	assert(extra.frames >= 1, 'extra.frames >= 1', 2)
	assert(extra.first_frame >= 0, 'extra.first_frame >= 0', 2)
	assert(extra.mipmap_count >= 1, 'extra.mipmap_count >= 1', 2)
	assert(IsColor(extra.fill), 'IsColor(extra.fill)', 2)

	if extra.mipmap_count > power_of_two[math.min(width, height)] then
		error(string.format('Can not create image with %d mip levels due to image size of %dx%d', extra.mipmap_count, width, height), 2)
	end

	if extra.mipmap_count == 1 then
		extra.flags = extra.flags:bor(TEXTUREFLAGS_NOMIP, TEXTUREFLAGS_NOLOD)
	end

	local bytes = DLib.BytesBuffer('VTF\x00')
	bytes:Seek(4)

	local size = 80

	bytes:WriteUInt32LE(7)
	bytes:WriteUInt32LE(version)
	bytes:WriteUInt32LE(size)

	size = size - 12

	bytes:WriteUInt16LE(width)
	bytes:WriteUInt16LE(height)

	size = size - 4

	bytes:WriteUInt32LE(extra.flags)
	bytes:WriteUInt16LE(extra.frames)
	bytes:WriteUInt16LE(extra.first_frame)

	size = size - 8

	bytes:WriteUInt32(0)

	size = size - 4

	bytes:WriteFloatLE(extra.fill.r / 255)
	bytes:WriteFloatLE(extra.fill.g / 255)
	bytes:WriteFloatLE(extra.fill.b / 255)

	size = size - 12

	bytes:WriteUInt32(0)
	bytes:WriteFloatLE(extra.bumpmap_scale)

	size = size - 8

	bytes:WriteUInt32LE(format)
	bytes:WriteUByte(extra.mipmap_count)

	size = size - 5

	bytes:WriteUInt32LE(VTFObject.Formats.IMAGE_FORMAT_DXT1)

	size = size - 4

	local thumb_width, thumb_height

	if width == height then
		thumb_width, thumb_height = 16, 16
	elseif width <= 16 and height <= 16 then
		thumb_width, thumb_height = width, height
	elseif width < height then
		thumb_height = 16
		thumb_width = math.max(1, (width / height) * 16)
	else
		thumb_width = 16
		thumb_height = math.max(1, (height / width) * 16)
	end

	bytes:WriteUByte(thumb_width)
	bytes:WriteUByte(thumb_height)

	size = size - 2

	if version >= 2 then
		bytes:WriteUInt16LE(extra.depth)
		size = size - 2
	end

	if size > 0 then
		bytes:WriteBinary(string.rep('\x00', size - 4)) -- including vtf\0
	end

	local faces = bit.band(extra.flags, TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP and 6 or 1

	local resolutions = {}
	local w, h = width, height

	for mipmap = extra.mipmap_count, 1, -1 do
		resolutions[mipmap] = {w, h}
		w = w / 2
		h = h / 2
	end

	-- write DXT1 thumbnail
	DLib.DXT1.Create(thumb_width, thumb_height, extra.fill, bytes)

	-- from smallest to largest
	for mipmap = 1, extra.mipmap_count do
		local w, h = resolutions[mipmap][1], resolutions[mipmap][2]

		-- from first to last
		for frame = 1, extra.frames do
			-- from first to last
			for face = 1, faces do
				-- for each Z slice (smallest to largest)
				for zDepth = 1, extra.depth do
					reader.Create(w, h, extra.fill, bytes)
				end
			end
		end
	end

	bytes:Seek(0)
	return DLib.VTF(bytes)
end

function VTF:ctor(bytes)
	self.pointer = bytes:Tell()
	-- self.buffer = bytes

	local readHead = VTFObject.HeaderStruct(bytes)
	local readHead2, readHead3

	if readHead.version[2] >= 2 then
		readHead2 = VTFObject.HeaderStruct72(bytes)
	end

	if readHead.version[2] >= 3 then
		readHead3 = VTFObject.HeaderStruct73(bytes)
	end

	self.version_string = string.format('%d.%d', readHead.version[1], readHead.version[2])

	self.version_major = readHead.version[1]
	self.version_minor = readHead.version[2]

	self.width = readHead.width
	self.height = readHead.height
	self.flags = readHead.flags
	self.frames = readHead.frames
	self.first_frame = readHead.firstFrame
	--self.reflectivity = Vector(1 - readHead.reflectivity[1], 1 - readHead.reflectivity[2], 1 - readHead.reflectivity[3])
	self.high_res_image_format = readHead.highResImageFormat
	self.low_res_image_format = readHead.lowResImageFormat
	self.low_width = readHead.lowResImageWidth
	self.low_height = readHead.lowResImageHeight
	self.mipmap_count = readHead.mipmapCount

	if readHead2 then
		self.depth = readHead2.depth
	else
		self.depth = 1
	end

	if readHead3 then
		self.num_resources = readHead3.numResources
	end

	self.faces = 1

	if bit.band(self.flags, TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP then
		self.faces = 6
	end

	assert(self.low_res_image_format == VTFObject.Formats.IMAGE_FORMAT_DXT1, 'self.low_res_image_format ~= VTFObject.Formats.IMAGE_FORMAT_DXT1 (' .. self.low_res_image_format .. ' ~= ' .. VTFObject.Formats.IMAGE_FORMAT_DXT1 .. ')')

	local resolutions = {}
	local w, h = self.width, self.height

	for mipmap = self.mipmap_count, 1, -1 do
		resolutions[mipmap] = {w, h}
		w = w / 2
		h = h / 2
	end

	self.mipmap_resolutions = resolutions
	self.mipmaps = {}
	self.mipmaps_obj = {}

	local reader = assert(VTFObject.Readers[VTFObject.Formats[self.high_res_image_format]], 'Unsupported image format ' .. VTFObject.Formats[self.high_res_image_format])

	if self.version_minor <= 2 then
		if bytes:Tell() < readHead.headerSize then
			bytes:Walk(readHead.headerSize - bytes:Tell())
		end

		-- DXT1: each block takes 64 bits of data, or 8 bytes
		-- width / 4 * height / 4 * 8
		-- skip it
		bytes:Walk(self.low_width * self.low_height / 2)

		-- from smallest to largest
		for mipmap = 1, self.mipmap_count do
			local w, h = resolutions[mipmap][1], resolutions[mipmap][2]

			-- from first to last
			for frame = 1, self.frames do
				-- from first to last
				for face = 1, self.faces do
					-- for each Z slice (smallest to largest)
					for zDepth = 1, self.depth do
						local walk = reader.CountBytes(w, h)
						self.mipmaps[mipmap] = DLib.BytesBufferView(bytes:Tell(), bytes:Tell() + walk, bytes)
						self.mipmaps_obj[mipmap] = reader(self.mipmaps[mipmap], w, h)
						bytes:Walk(walk)
					end
				end
			end
		end
	else
		self.resources = {}

		for i = 1, self.num_resources do
			table.insert(self.resources, VTFObject.ResourceInfoStruct(bytes))
		end
	end

	self.bytes = bytes
end

function VTF:ToString()
	return self.bytes:ToString()
end

local Color = Color

local function subsample_block(getblock)
	-- 0x0 texel
	local a, b, c, d = getblock[1], getblock[2], getblock[5], getblock[6]
	local sample_result = {}

	sample_result[1] = Color(
		(a.r + b.r + c.r + d.r) * 0.25,
		(a.g + b.g + c.g + d.g) * 0.25,
		(a.b + b.b + c.b + d.b) * 0.25
	)

	-- 1x0
	a, b, c, d = getblock[3], getblock[4], getblock[7], getblock[8]

	sample_result[2] = Color(
		(a.r + b.r + c.r + d.r) * 0.25,
		(a.g + b.g + c.g + d.g) * 0.25,
		(a.b + b.b + c.b + d.b) * 0.25
	)

	-- 0x1
	a, b, c, d = getblock[9], getblock[10], getblock[13], getblock[14]

	sample_result[3] = Color(
		(a.r + b.r + c.r + d.r) * 0.25,
		(a.g + b.g + c.g + d.g) * 0.25,
		(a.b + b.b + c.b + d.b) * 0.25
	)

	-- 1x1
	a, b, c, d = getblock[11], getblock[12], getblock[15], getblock[16]

	sample_result[4] = Color(
		(a.r + b.r + c.r + d.r) * 0.25,
		(a.g + b.g + c.g + d.g) * 0.25,
		(a.b + b.b + c.b + d.b) * 0.25
	)

	return sample_result
end

local function sample_block(getblock)
	local sampleR, sampleG, sampleB = 0, 0, 0

	for i = 1, 16 do
		local col = getblock[i]
		sampleR, sampleG, sampleB = sampleR + col.r, sampleG + col.g, sampleB + col.b
	end

	return Color(sampleR * 0.0625, sampleG * 0.0625, sampleB * 0.0625)
end

local function supersample_block(sample_from, blockX, blockY, level)
	if level == 0 then
		return sample_block(sample_from:GetBlock(blockX, blockY))
	end

	local step = math.pow(2, level - 1)

	local a = supersample_block(sample_from, blockX, blockY, level - 1)
	local b = supersample_block(sample_from, blockX + step, blockY, level - 1)
	local c = supersample_block(sample_from, blockX, blockY + step, level - 1)
	local d = supersample_block(sample_from, blockX + step, blockY + step, level - 1)

	return Color(
		(a.r + b.r + c.r + d.r) * 0.25,
		(a.g + b.g + c.g + d.g) * 0.25,
		(a.b + b.b + c.b + d.b) * 0.25
	)
end

-- if fast - sample *previous* mip (so it sample only 4 texels of bigger mip)
-- if supersample, then it sample biggest mip and as current mip become smaller, more texels are sampled
function VTF:AutoGenerateMips(supersample)
	if self.mipmap_count == 1 then return false end
	if supersample == nil then supersample = true end

	if supersample then
		local biggest = self.mipmaps_obj[self.mipmap_count]
		local _w, _h = biggest.width, biggest.height

		local sample_width = 1
		local supersample_level = 1
		local grid_width = 2

		-- from biggest to smallest
		for mipmap = self.mipmap_count - 1, 1, -1 do
			local current = self.mipmaps_obj[mipmap]
			local w, h = current.width_blocks, current.height_blocks

			-- sampling 2x2 blocks per 1 texel on mip texture
			-- so let's optimize that by sampling (4 blocks of 2x2 texels at once) * 4
			if supersample_level == 1 then
				for blockX = 0, w - 1 do
					for blockY = 0, h - 1 do
						local block = {}

						-- sampling 0x0 to 1x1
						local sample = subsample_block(biggest:GetBlock(blockX * 2, blockY * 2))

						block[1] = sample[1]
						block[2] = sample[2]
						block[5] = sample[3]
						block[6] = sample[4]

						-- sampling 2x0 to 3x1
						sample = subsample_block(biggest:GetBlock(blockX * 2 + 1, blockY * 2))

						block[3] = sample[1]
						block[4] = sample[2]
						block[7] = sample[3]
						block[8] = sample[4]

						-- sampling 0x2 to 1x2
						sample = subsample_block(biggest:GetBlock(blockX * 2, blockY * 2 + 1))

						block[9] = sample[1]
						block[10] = sample[2]
						block[13] = sample[3]
						block[14] = sample[4]

						-- sampling 2x2 to 3x3
						sample = subsample_block(biggest:GetBlock(blockX * 2 + 1, blockY * 2 + 1))

						block[11] = sample[1]
						block[12] = sample[2]
						block[15] = sample[3]
						block[16] = sample[4]

						current:SetBlock(blockX, blockY, block)
					end
				end

			-- sample entire blocks for one texel
			elseif supersample_level == 2 then
				for blockX = 0, w - 1 do
					for blockY = 0, h - 1 do
						current:SetBlock(blockX, blockY, {
							sample_block(biggest:GetBlock(blockX * 4,       blockY * 4)),
							sample_block(biggest:GetBlock(blockX * 4 + 1,   blockY * 4)),
							sample_block(biggest:GetBlock(blockX * 4 + 2,   blockY * 4)),
							sample_block(biggest:GetBlock(blockX * 4 + 3,   blockY * 4)),

							sample_block(biggest:GetBlock(blockX * 4,       blockY * 4 + 1)),
							sample_block(biggest:GetBlock(blockX * 4 + 1,   blockY * 4 + 1)),
							sample_block(biggest:GetBlock(blockX * 4 + 2,   blockY * 4 + 1)),
							sample_block(biggest:GetBlock(blockX * 4 + 3,   blockY * 4 + 1)),

							sample_block(biggest:GetBlock(blockX * 4,       blockY * 4 + 2)),
							sample_block(biggest:GetBlock(blockX * 4 + 1,   blockY * 4 + 2)),
							sample_block(biggest:GetBlock(blockX * 4 + 2,   blockY * 4 + 2)),
							sample_block(biggest:GetBlock(blockX * 4 + 3,   blockY * 4 + 2)),

							sample_block(biggest:GetBlock(blockX * 4,       blockY * 4 + 3)),
							sample_block(biggest:GetBlock(blockX * 4 + 1,   blockY * 4 + 3)),
							sample_block(biggest:GetBlock(blockX * 4 + 2,   blockY * 4 + 3)),
							sample_block(biggest:GetBlock(blockX * 4 + 3,   blockY * 4 + 3)),
						})
					end
				end

			-- recursive supersampling
			else
				local step = math.pow(2, supersample_level)
				local step2 = math.pow(2, supersample_level - 2)

				for blockX = 0, w - 1 do
					for blockY = 0, h - 1 do
						current:SetBlock(blockX, blockY, {
							supersample_block(biggest, blockX * step + step2 * 0, blockY * step + step2 * 0,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 1, blockY * step + step2 * 0,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 2, blockY * step + step2 * 0,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 3, blockY * step + step2 * 0,  supersample_level - 2),

							supersample_block(biggest, blockX * step + step2 * 0, blockY * step + step2 * 1,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 1, blockY * step + step2 * 1,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 2, blockY * step + step2 * 1,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 3, blockY * step + step2 * 1,  supersample_level - 2),

							supersample_block(biggest, blockX * step + step2 * 0, blockY * step + step2 * 2,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 1, blockY * step + step2 * 2,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 2, blockY * step + step2 * 2,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 3, blockY * step + step2 * 2,  supersample_level - 2),

							supersample_block(biggest, blockX * step + step2 * 0, blockY * step + step2 * 3,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 1, blockY * step + step2 * 3,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 2, blockY * step + step2 * 3,  supersample_level - 2),
							supersample_block(biggest, blockX * step + step2 * 3, blockY * step + step2 * 3,  supersample_level - 2),
						})
					end
				end
			end

			supersample_level = supersample_level + 1
			sample_width = sample_width * 2
			grid_width = grid_width * 2
		end
	else
		-- from biggest to smallest
		for mipmap = self.mipmap_count - 1, 1, -1 do
			local prev = self.mipmaps_obj[mipmap + 1]
			local current = self.mipmaps_obj[mipmap]

			local w, h = current.width_blocks, current.height_blocks
			local _w, _h = prev.width, prev.height

			for blockX = 0, w - 1 do
				for blockY = 0, h - 1 do
					local block = {}

					for x = 0, 3 do
						for y = 0, 3 do
							local aX, aY = (blockX * 4 + x) * 2, (blockY * 4 + y) * 2

							local pixel = prev:GetPixel(aX, aY)
							local sampleR, sampleG, sampleB = pixel.r, pixel.g, pixel.b
							local samples = 1

							if aX + 1 < _w then
								pixel = prev:GetPixel(aX + 1, aY)
								sampleR = sampleR + pixel.r
								sampleG = sampleG + pixel.g
								sampleB = sampleB + pixel.b
								samples = samples + 1
							end

							if aY + 1 < _h then
								pixel = prev:GetPixel(aX, aY + 1)
								sampleR = sampleR + pixel.r
								sampleG = sampleG + pixel.g
								sampleB = sampleB + pixel.b
								samples = samples + 1
							end

							if aX + 1 < _w and aY + 1 >= 0 then
								pixel = prev:GetPixel(aX + 1, aY + 1)
								sampleR = sampleR + pixel.r
								sampleG = sampleG + pixel.g
								sampleB = sampleB + pixel.b
								samples = samples + 1
							end

							block[x + y * 4 + 1] = Color(sampleR / samples, sampleG / samples, sampleB / samples)
						end
					end

					current:SetBlock(blockX, blockY, block)
				end
			end
		end
	end

	return true
end

VTFObject.HeaderStruct = DLib.BytesBuffer.CompileStructure([[
	char                            signature[4];       // File signature ("VTF\0"). (or as little-endian integer, 0x00465456)
	little endian unsigned int      version[2];         // version[0].version[1] (currently 7.2).
	little endian unsigned int      headerSize;         // Size of the header struct  (16 byte aligned; currently 80 bytes) + size of the resources dictionary (7.3+).
	little endian unsigned short    width;              // Width of the largest mipmap in pixels. Must be a power of 2.
	little endian unsigned short    height;             // Height of the largest mipmap in pixels. Must be a power of 2.
	little endian unsigned int      flags;              // VTF flags.
	little endian unsigned short    frames;             // Number of frames, if animated (1 for no animation).
	little endian unsigned short    firstFrame;         // First frame in animation (0 based).
	unsigned char                   padding0[4];        // reflectivity padding (16 byte alignment).
	little endian float                           reflectivity[3];    // reflectivity vector.
	unsigned char                   padding1[4];        // reflectivity padding (8 byte packing).
	little endian float                           bumpmapScale;       // Bumpmap scale.
	little endian unsigned int      highResImageFormat; // High resolution image format.
	unsigned char                   mipmapCount;        // Number of mipmaps.
	little endian unsigned int      lowResImageFormat;  // Low resolution image format (always DXT1).
	unsigned char                   lowResImageWidth;   // Low resolution image width.
	unsigned char                   lowResImageHeight;  // Low resolution image height.
]])

VTFObject.HeaderStruct72 = DLib.BytesBuffer.CompileStructure([[
	// 7.2+
	little endian unsigned short    depth;              // Depth of the largest mipmap in pixels.
														// Must be a power of 2. Is 1 for a 2D texture.
]])

VTFObject.HeaderStruct73 = DLib.BytesBuffer.CompileStructure([[
	// 7.3+
	little endian unsigned char     padding2[3];        // depth padding (4 byte alignment).
	little endian unsigned int      numResources;       // Number of resources this vtf has. The max appears to be 32.

	little endian unsigned char     padding3[8];        // Necessary on certain compilers
]])

VTFObject.ResourceInfoStruct = DLib.BytesBuffer.CompileStructure([[
	unsigned char                   tag[3];             // A three-byte "tag" that identifies what this resource is.
	unsigned char                   flags;              // Resource entry flags. The only known flag is 0x2, which indicates that no data chunk corresponds to this resource.
	little endian unsigned int      offset;             // The offset of this resource's data in the file.
]])

DLib.VTF = DLib.CreateMoonClassBare('VTF', VTF, VTFObject)
