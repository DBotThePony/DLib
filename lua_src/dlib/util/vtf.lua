
-- Copyright (C) 2017-2020 DBotThePony

-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do so,
-- subject to the following conditions:

-- The above copyright notice and this permission notice shall be included in all copies
-- or substantial portions of the Software.

-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
-- INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
-- PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
-- FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-- OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-- DEALINGS IN THE SOFTWARE.

_G.TEXTUREFLAGS_POINTSAMPLE                   = 0x00000001
_G.TEXTUREFLAGS_TRILINEAR                     = 0x00000002
_G.TEXTUREFLAGS_CLAMPS                        = 0x00000004
_G.TEXTUREFLAGS_CLAMPT                        = 0x00000008
_G.TEXTUREFLAGS_ANISOTROPIC                   = 0x00000010
_G.TEXTUREFLAGS_HINT_DXT5                     = 0x00000020
_G.TEXTUREFLAGS_SRGB                          = 0x00000040
_G.TEXTUREFLAGS_NORMAL                        = 0x00000080
_G.TEXTUREFLAGS_NOMIP                         = 0x00000100
_G.TEXTUREFLAGS_NOLOD                         = 0x00000200
_G.TEXTUREFLAGS_ALL_MIPS                      = 0x00000400
_G.TEXTUREFLAGS_PROCEDURAL                    = 0x00000800

-- These are automatically generated by vtex from the texture data.
_G.TEXTUREFLAGS_ONEBITALPHA                   = 0x00001000
_G.TEXTUREFLAGS_EIGHTBITALPHA                 = 0x00002000

-- newer flags from the *.txt config file
_G.TEXTUREFLAGS_ENVMAP                        = 0x00004000
_G.TEXTUREFLAGS_RENDERTARGET                  = 0x00008000
_G.TEXTUREFLAGS_DEPTHRENDERTARGET             = 0x00010000
_G.TEXTUREFLAGS_NODEBUGOVERRIDE               = 0x00020000
_G.TEXTUREFLAGS_SINGLECOPY                    = 0x00040000
_G.TEXTUREFLAGS_STAGING_MEMORY                = 0x00080000
_G.TEXTUREFLAGS_IMMEDIATE_CLEANUP             = 0x00100000
_G.TEXTUREFLAGS_IGNORE_PICMIP                 = 0x00200000
_G.TEXTUREFLAGS_UNUSED_00400000               = 0x00400000
_G.TEXTUREFLAGS_NODEPTHBUFFER                 = 0x00800000
_G.TEXTUREFLAGS_UNUSED_01000000               = 0x01000000
_G.TEXTUREFLAGS_CLAMPU                        = 0x02000000
_G.TEXTUREFLAGS_VERTEXTEXTURE                 = 0x04000000                 -- Useable as a vertex texture
_G.TEXTUREFLAGS_SSBUMP                        = 0x08000000
_G.TEXTUREFLAGS_UNUSED_10000000               = 0x10000000

-- Clamp to border color on all texture coordinates
_G.TEXTUREFLAGS_BORDER                        = 0x20000000
_G.TEXTUREFLAGS_UNUSED_40000000               = 0x40000000
_G.TEXTUREFLAGS_UNUSED_80000000               = 0x80000000

local TEXTUREFLAGS_POINTSAMPLE =       TEXTUREFLAGS_POINTSAMPLE
local TEXTUREFLAGS_TRILINEAR =         TEXTUREFLAGS_TRILINEAR
local TEXTUREFLAGS_CLAMPS =            TEXTUREFLAGS_CLAMPS
local TEXTUREFLAGS_CLAMPT =            TEXTUREFLAGS_CLAMPT
local TEXTUREFLAGS_ANISOTROPIC =       TEXTUREFLAGS_ANISOTROPIC
local TEXTUREFLAGS_HINT_DXT5 =         TEXTUREFLAGS_HINT_DXT5
local TEXTUREFLAGS_SRGB =              TEXTUREFLAGS_SRGB
local TEXTUREFLAGS_NORMAL =            TEXTUREFLAGS_NORMAL
local TEXTUREFLAGS_NOMIP =             TEXTUREFLAGS_NOMIP
local TEXTUREFLAGS_NOLOD =             TEXTUREFLAGS_NOLOD
local TEXTUREFLAGS_ALL_MIPS =          TEXTUREFLAGS_ALL_MIPS
local TEXTUREFLAGS_PROCEDURAL =        TEXTUREFLAGS_PROCEDURAL
local TEXTUREFLAGS_ONEBITALPHA =       TEXTUREFLAGS_ONEBITALPHA
local TEXTUREFLAGS_EIGHTBITALPHA =     TEXTUREFLAGS_EIGHTBITALPHA
local TEXTUREFLAGS_ENVMAP =            TEXTUREFLAGS_ENVMAP
local TEXTUREFLAGS_RENDERTARGET =      TEXTUREFLAGS_RENDERTARGET
local TEXTUREFLAGS_DEPTHRENDERTARGET = TEXTUREFLAGS_DEPTHRENDERTARGET
local TEXTUREFLAGS_NODEBUGOVERRIDE =   TEXTUREFLAGS_NODEBUGOVERRIDE
local TEXTUREFLAGS_SINGLECOPY =        TEXTUREFLAGS_SINGLECOPY
local TEXTUREFLAGS_STAGING_MEMORY =    TEXTUREFLAGS_STAGING_MEMORY
local TEXTUREFLAGS_IMMEDIATE_CLEANUP = TEXTUREFLAGS_IMMEDIATE_CLEANUP
local TEXTUREFLAGS_IGNORE_PICMIP =     TEXTUREFLAGS_IGNORE_PICMIP
local TEXTUREFLAGS_UNUSED_00400000 =   TEXTUREFLAGS_UNUSED_00400000
local TEXTUREFLAGS_NODEPTHBUFFER =     TEXTUREFLAGS_NODEPTHBUFFER
local TEXTUREFLAGS_UNUSED_01000000 =   TEXTUREFLAGS_UNUSED_01000000
local TEXTUREFLAGS_CLAMPU =            TEXTUREFLAGS_CLAMPU
local TEXTUREFLAGS_VERTEXTEXTURE =     TEXTUREFLAGS_VERTEXTEXTURE
local TEXTUREFLAGS_SSBUMP =            TEXTUREFLAGS_SSBUMP
local TEXTUREFLAGS_UNUSED_10000000 =   TEXTUREFLAGS_UNUSED_10000000
local TEXTUREFLAGS_BORDER =            TEXTUREFLAGS_BORDER
local TEXTUREFLAGS_UNUSED_40000000 =   TEXTUREFLAGS_UNUSED_40000000
local TEXTUREFLAGS_UNUSED_80000000 =   TEXTUREFLAGS_UNUSED_80000000


local VTF = {}
local VTFObject = {}

local Formats = {
	'IMAGE_FORMAT_NONE',
	'IMAGE_FORMAT_RGBA8888',
	'IMAGE_FORMAT_ABGR8888',
	'IMAGE_FORMAT_RGB888',
	'IMAGE_FORMAT_BGR888',
	'IMAGE_FORMAT_RGB565',
	'IMAGE_FORMAT_I8',
	'IMAGE_FORMAT_IA88',
	'IMAGE_FORMAT_P8',
	'IMAGE_FORMAT_A8',
	'IMAGE_FORMAT_RGB888_BLUESCREEN',
	'IMAGE_FORMAT_BGR888_BLUESCREEN',
	'IMAGE_FORMAT_ARGB8888',
	'IMAGE_FORMAT_BGRA8888',
	'IMAGE_FORMAT_DXT1',
	'IMAGE_FORMAT_DXT3',
	'IMAGE_FORMAT_DXT5',
	'IMAGE_FORMAT_BGRX8888',
	'IMAGE_FORMAT_BGR565',
	'IMAGE_FORMAT_BGRX5551',
	'IMAGE_FORMAT_BGRA4444',
	'IMAGE_FORMAT_DXT1_ONEBITALPHA',
	'IMAGE_FORMAT_BGRA5551',
	'IMAGE_FORMAT_UV88',
	'IMAGE_FORMAT_UVWQ8888',
	'IMAGE_FORMAT_RGBA16161616F',
	'IMAGE_FORMAT_RGBA16161616',
	'IMAGE_FORMAT_UVLX8888'
}

VTFObject.Formats = {}

for i = 1, #Formats do
	VTFObject.Formats[Formats[i]] = i - 2
	VTFObject.Formats[i - 2] = Formats[i]

	_G[Formats[i]] = i - 2
end

VTFObject.Readers = {}
VTFObject.Readers.IMAGE_FORMAT_DXT1 = DLib.DXT1
VTFObject.Readers.IMAGE_FORMAT_DXT3 = DLib.DXT3
VTFObject.Readers.IMAGE_FORMAT_DXT5 = DLib.DXT5

local color_white = Color()

local power_of_two = {}

for i = 0, 14 do
	power_of_two[math.pow(2, i)] = true
end

-- version is a number from 1 (7.1) to 5 (7.5)
function VTFObject.Create(version, width, height, format, extra)
	assert(isnumber(version), 'isnumber(version)', 2)
	version = version:floor()
	assert(version >= 1 and version <= 5, 'version does not belong to [1, 5] interval', 2)

	assert(isnumber(width), 'isnumber(width)', 2)
	assert(isnumber(height), 'isnumber(height)', 2)
	assert(power_of_two[width], 'Width is not power of two', 2)
	assert(power_of_two[height], 'Height is not power of two', 2)

	if isstring(format) then
		format = assert(VTFObject.Formats[format], 'Invalid format ' .. format .. '!', 2)
	elseif not VTFObject.Formats[format] then
		error('Invalid format index ' .. format .. '!', 2)
	end

	local reader = VTFObject.Readers[VTFObject.Formats[format]]
	if not reader then
		error('Unsupported image format ' .. VTFObject.Formats[format] .. '!', 2)
	end

	if not istable(extra) then
		extra = {}
	end

	if extra.flags == nil then
		extra.flags = 0
	end

	if extra.frames == nil then
		extra.frames = 1
	end

	if extra.first_frame == nil then
		extra.first_frame = 0
	end

	if extra.fill == nil then
		extra.fill = color_white
	end

	if extra.bumpmap_scale == nil then
		extra.bumpmap_scale = 1
	end

	if extra.mipmap_count == nil then
		extra.mipmap_count = 1
	end

	if extra.depth == nil then
		extra.depth = 1
	end

	assert(isnumber(extra.flags), 'isnumber(extra.flags)', 2)
	assert(isnumber(extra.frames), 'isnumber(extra.frames)', 2)
	assert(isnumber(extra.first_frame), 'isnumber(extra.first_frame)', 2)
	assert(isnumber(extra.bumpmap_scale), 'isnumber(extra.bumpmap_scale)', 2)
	assert(isnumber(extra.mipmap_count), 'isnumber(extra.mipmap_count)', 2)
	assert(isnumber(extra.depth), 'isnumber(extra.depth)', 2)
	assert(power_of_two[extra.depth], 'extra.depth is not power of two', 2)
	assert(extra.frames >= 1, 'extra.frames >= 1', 2)
	assert(extra.first_frame >= 0, 'extra.first_frame >= 0', 2)
	assert(IsColor(extra.fill), 'IsColor(extra.fill)', 2)

	if extra.mipmap_count == 1 then
		extra.flags = extra.flags:bor(TEXTUREFLAGS_NOMIP, TEXTUREFLAGS_NOLOD)
	end

	local bytes = DLib.BytesBuffer('VTF\x00')
	bytes:Seek(4)

	local size = 80

	bytes:WriteUInt32LE(7)
	bytes:WriteUInt32LE(version)
	bytes:WriteUInt32LE(size)

	size = size - 12

	bytes:WriteUInt16LE(width)
	bytes:WriteUInt16LE(height)

	size = size - 4

	bytes:WriteUInt32LE(extra.flags)
	bytes:WriteUInt16LE(extra.frames)
	bytes:WriteUInt16LE(extra.first_frame)

	size = size - 8

	bytes:WriteUInt32(0)

	size = size - 4

	bytes:WriteFloatLE(extra.fill.r / 255)
	bytes:WriteFloatLE(extra.fill.g / 255)
	bytes:WriteFloatLE(extra.fill.b / 255)

	size = size - 12

	bytes:WriteUInt32(0)
	bytes:WriteFloatLE(extra.bumpmap_scale)

	size = size - 8

	bytes:WriteUInt32LE(format)
	bytes:WriteUByte(extra.mipmap_count)

	size = size - 5

	bytes:WriteUInt32LE(VTFObject.Formats.IMAGE_FORMAT_DXT1)

	size = size - 4

	local thumb_width, thumb_height

	if width == height then
		thumb_width, thumb_height = 16, 16
	elseif width <= 16 and height <= 16 then
		thumb_width, thumb_height = width, height
	elseif width < height then
		thumb_height = 16
		thumb_width = math.max(1, (width / height) * 16)
	else
		thumb_width = 16
		thumb_height = math.max(1, (height / width) * 16)
	end

	bytes:WriteUByte(thumb_width)
	bytes:WriteUByte(thumb_height)

	size = size - 2

	if version >= 2 then
		bytes:WriteUInt16LE(extra.depth)
		size = size - 2
	end

	if size > 0 then
		bytes:WriteBinary(string.rep('\x00', size - 4)) -- including vtf\0
	end

	local faces = bit.band(extra.flags, TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP and 6 or 1

	local resolutions = {}
	local w, h = width, height

	for mipmap = extra.mipmap_count, 1, -1 do
		resolutions[mipmap] = {w, h}
		w = w / 2
		h = h / 2
	end

	-- write DXT1 thumbnail
	DLib.DXT1.Create(thumb_width, thumb_height, extra.fill, bytes)

	-- from smallest to largest
	for mipmap = 1, extra.mipmap_count do
		local w, h = resolutions[mipmap][1], resolutions[mipmap][2]

		-- from first to last
		for frame = 1, extra.frames do
			-- from first to last
			for face = 1, faces do
				-- for each Z slice (smallest to largest)
				for zDepth = 1, extra.depth do
					reader.Create(w, h, extra.fill, bytes)
				end
			end
		end
	end

	bytes:Seek(0)
	return DLib.VTF(bytes)
end

function VTF:ctor(bytes)
	self.pointer = bytes:Tell()
	-- self.buffer = bytes

	local readHead = VTFObject.HeaderStruct(bytes)
	local readHead2, readHead3

	if readHead.version[2] >= 2 then
		readHead2 = VTFObject.HeaderStruct72(bytes)
	end

	if readHead.version[2] >= 3 then
		readHead3 = VTFObject.HeaderStruct73(bytes)
	end

	self.version_string = string.format('%d.%d', readHead.version[1], readHead.version[2])

	self.version_major = readHead.version[1]
	self.version_minor = readHead.version[2]

	self.width = readHead.width
	self.height = readHead.height
	self.flags = readHead.flags
	self.frames = readHead.frames
	self.first_frame = readHead.firstFrame
	--self.reflectivity = Vector(1 - readHead.reflectivity[1], 1 - readHead.reflectivity[2], 1 - readHead.reflectivity[3])
	self.high_res_image_format = readHead.highResImageFormat
	self.low_res_image_format = readHead.lowResImageFormat
	self.low_width = readHead.lowResImageWidth
	self.low_height = readHead.lowResImageHeight
	self.mipmap_count = readHead.mipmapCount

	if readHead2 then
		self.depth = readHead2.depth
	else
		self.depth = 1
	end

	if readHead3 then
		self.num_resources = readHead3.numResources
	end

	self.faces = 1

	if bit.band(self.flags, TEXTUREFLAGS_ENVMAP) == TEXTUREFLAGS_ENVMAP then
		self.faces = 6
	end

	assert(self.low_res_image_format == VTFObject.Formats.IMAGE_FORMAT_DXT1, 'self.low_res_image_format ~= VTFObject.Formats.IMAGE_FORMAT_DXT1 (' .. self.low_res_image_format .. ' ~= ' .. VTFObject.Formats.IMAGE_FORMAT_DXT1 .. ')')

	local resolutions = {}
	local w, h = self.width, self.height

	for mipmap = self.mipmap_count, 1, -1 do
		resolutions[mipmap] = {w, h}
		w = w / 2
		h = h / 2
	end

	self.mipmap_resolutions = resolutions
	self.mipmaps = {}
	self.mipmaps_obj = {}

	local reader = assert(VTFObject.Readers[VTFObject.Formats[self.high_res_image_format]], 'Unsupported image format ' .. VTFObject.Formats[self.high_res_image_format])

	if self.version_minor <= 2 then
		if bytes:Tell() < readHead.headerSize then
			bytes:Walk(readHead.headerSize - bytes:Tell())
		end

		-- DXT1: each block takes 64 bits of data, or 8 bytes
		-- width / 4 * height / 4 * 8
		-- skip it
		bytes:Walk(self.low_width * self.low_height / 2)

		-- from smallest to largest
		for mipmap = 1, self.mipmap_count do
			local w, h = resolutions[mipmap][1], resolutions[mipmap][2]

			-- from first to last
			for frame = 1, self.frames do
				-- from first to last
				for face = 1, self.faces do
					-- for each Z slice (smallest to largest)
					for zDepth = 1, self.depth do
						local walk = reader.CountBytes(w, h)
						self.mipmaps[mipmap] = DLib.BytesBufferView(bytes:Tell(), bytes:Tell() + walk, bytes)
						self.mipmaps_obj[mipmap] = reader(self.mipmaps[mipmap], w, h)
						bytes:Walk(walk)
					end
				end
			end
		end
	else
		self.resources = {}

		for i = 1, self.num_resources do
			table.insert(self.resources, VTFObject.ResourceInfoStruct(bytes))
		end
	end

	self.bytes = bytes
end

function VTF:ToString()
	return self.bytes:ToString()
end

VTFObject.HeaderStruct = DLib.BytesBuffer.CompileStructure([[
	char                            signature[4];       // File signature ("VTF\0"). (or as little-endian integer, 0x00465456)
	little endian unsigned int      version[2];         // version[0].version[1] (currently 7.2).
	little endian unsigned int      headerSize;         // Size of the header struct  (16 byte aligned; currently 80 bytes) + size of the resources dictionary (7.3+).
	little endian unsigned short    width;              // Width of the largest mipmap in pixels. Must be a power of 2.
	little endian unsigned short    height;             // Height of the largest mipmap in pixels. Must be a power of 2.
	little endian unsigned int      flags;              // VTF flags.
	little endian unsigned short    frames;             // Number of frames, if animated (1 for no animation).
	little endian unsigned short    firstFrame;         // First frame in animation (0 based).
	unsigned char                   padding0[4];        // reflectivity padding (16 byte alignment).
	little endian float                           reflectivity[3];    // reflectivity vector.
	unsigned char                   padding1[4];        // reflectivity padding (8 byte packing).
	little endian float                           bumpmapScale;       // Bumpmap scale.
	little endian unsigned int      highResImageFormat; // High resolution image format.
	unsigned char                   mipmapCount;        // Number of mipmaps.
	little endian unsigned int      lowResImageFormat;  // Low resolution image format (always DXT1).
	unsigned char                   lowResImageWidth;   // Low resolution image width.
	unsigned char                   lowResImageHeight;  // Low resolution image height.
]])

VTFObject.HeaderStruct72 = DLib.BytesBuffer.CompileStructure([[
	// 7.2+
	little endian unsigned short    depth;              // Depth of the largest mipmap in pixels.
														// Must be a power of 2. Is 1 for a 2D texture.
]])

VTFObject.HeaderStruct73 = DLib.BytesBuffer.CompileStructure([[
	// 7.3+
	little endian unsigned char     padding2[3];        // depth padding (4 byte alignment).
	little endian unsigned int      numResources;       // Number of resources this vtf has. The max appears to be 32.

	little endian unsigned char     padding3[8];        // Necessary on certain compilers
]])

VTFObject.ResourceInfoStruct = DLib.BytesBuffer.CompileStructure([[
	unsigned char                   tag[3];             // A three-byte "tag" that identifies what this resource is.
	unsigned char                   flags;              // Resource entry flags. The only known flag is 0x2, which indicates that no data chunk corresponds to this resource.
	little endian unsigned int      offset;             // The offset of this resource's data in the file.
]])

DLib.VTF = DLib.CreateMoonClassBare('VTF', VTF, VTFObject)
